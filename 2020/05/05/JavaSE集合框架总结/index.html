<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JavaSE集合框架总结 | 戏子</title><meta name="description" content="JavaSE集合框架总结"><meta name="keywords" content="JavaSE"><meta name="author" content="戏子"><meta name="copyright" content="戏子"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Y960303802/image/avatar.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JavaSE集合框架总结"><meta name="twitter:description" content="JavaSE集合框架总结"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Y960303802/image/img2/549450.png"><meta property="og:type" content="article"><meta property="og:title" content="JavaSE集合框架总结"><meta property="og:url" content="https://www.yinpeng.fun/2020/05/05/JavaSE%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="戏子"><meta property="og:description" content="JavaSE集合框架总结"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Y960303802/image/img2/549450.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/Y960303802.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://www.yinpeng.fun/2020/05/05/JavaSE%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"><link rel="prev" title="Vue学习" href="https://www.yinpeng.fun/2020/05/11/Vue%E5%AD%A6%E4%B9%A0/"><link rel="next" title="Java中的反射与注解" href="https://www.yinpeng.fun/2020/05/05/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/Y960303802.github.io/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/Y960303802.github.io/atom.xml" title="戏子" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/Y960303802/image/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/Y960303802.github.io/archives/"><div class="headline">文章</div><div class="length_num">31</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/Y960303802.github.io/tags/"><div class="headline">标签</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/Y960303802.github.io/categories/"><div class="headline">分类</div><div class="length_num">29</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java集合框架总结"><span class="toc-number">1.</span> <span class="toc-text">Java集合框架总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#集合和数组的区别"><span class="toc-number">1.1.</span> <span class="toc-text">集合和数组的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Collection-接口"><span class="toc-number">1.2.</span> <span class="toc-text">1.Collection 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-单元素添加、删除操作："><span class="toc-number">1.2.1.</span> <span class="toc-text">(1) 单元素添加、删除操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-查询操作："><span class="toc-number">1.2.2.</span> <span class="toc-text">(2) 查询操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-组操作-：作用于元素组或整个集合"><span class="toc-number">1.2.3.</span> <span class="toc-text">(3) 组操作 ：作用于元素组或整个集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Collection转换为Object数组-："><span class="toc-number">1.2.4.</span> <span class="toc-text">(4) Collection转换为Object数组 ：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Iterator-接口"><span class="toc-number">1.3.</span> <span class="toc-text">1.2.Iterator 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-List接口"><span class="toc-number">1.4.</span> <span class="toc-text">2.  List接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何实现数组和-List-之间的转换？"><span class="toc-number">1.4.1.</span> <span class="toc-text">如何实现数组和 List 之间的转换？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-ListIterator接口"><span class="toc-number">1.5.</span> <span class="toc-text">2.1.ListIterator接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-LinkedList类"><span class="toc-number">1.6.</span> <span class="toc-text">2.3.1. LinkedList类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-ArrayList类"><span class="toc-number">1.7.</span> <span class="toc-text">2.3.2. ArrayList类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Set接口"><span class="toc-number">1.8.</span> <span class="toc-text">3.Set接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet与HashMap的区别"><span class="toc-number">1.8.1.</span> <span class="toc-text">HashSet与HashMap的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Hash表"><span class="toc-number">1.9.</span> <span class="toc-text">3.1. Hash表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Comparable接口和Comparator接口"><span class="toc-number">1.10.</span> <span class="toc-text">3.2. Comparable接口和Comparator接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-Comparable接口"><span class="toc-number">1.10.1.</span> <span class="toc-text">3.2.1. Comparable接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-Comparator接口"><span class="toc-number">1.10.2.</span> <span class="toc-text">3.2.2. Comparator接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-SortedSet接口"><span class="toc-number">1.11.</span> <span class="toc-text">3.3. SortedSet接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-HashSet类"><span class="toc-number">1.12.</span> <span class="toc-text">3.5.1.HashSet类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-TreeSet类"><span class="toc-number">1.13.</span> <span class="toc-text">3.5.2. TreeSet类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Map接口"><span class="toc-number">1.14.</span> <span class="toc-text">4. Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#"><span class="toc-number">1.14.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-7-VS-JDK1-8-比较"><span class="toc-number">1.14.2.</span> <span class="toc-text">JDK1.7 VS JDK1.8 比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Properties的使用"><span class="toc-number">1.14.3.</span> <span class="toc-text">Properties的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-HashMap类"><span class="toc-number">1.14.4.</span> <span class="toc-text">4.4.1. HashMap类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-TreeMap类"><span class="toc-number">1.14.5.</span> <span class="toc-text">4.4.2. TreeMap类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-number">1.15.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-2"><span class="toc-number">1.16.</span> <span class="toc-text"></span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/Y960303802/image/img2/549450.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/Y960303802.github.io/">戏子</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">JavaSE集合框架总结</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-05 11:35:46"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-05</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-29 16:57:33"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-29</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/Y960303802.github.io/categories/JavaSE/">JavaSE</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/Y960303802.github.io/categories/JavaSE/JavaSE%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/">JavaSE集合框架总结</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="Java集合框架总结"><a href="#Java集合框架总结" class="headerlink" title="Java集合框架总结"></a>Java集合框架总结</h2><p><strong>集合框架</strong>：用于存储数据的容器。 </p>
<h3 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h3><ul>
<li>数组是固定长度的；集合可变长度的。</li>
<li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li>
<li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</li>
</ul>
<p><img src="/Y960303802.github.io/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/Y960303802/image/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/4.png"  alt=""></p>
<p><img src="/Y960303802.github.io/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/Y960303802/image/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/3.png"  alt=""></p>
<p><img src="/Y960303802.github.io/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/Y960303802/image/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/4.jpg"  alt=""></p>
<blockquote>
<p>常用的集合类有哪些？</p>
</blockquote>
<p>Map接口和Collection接口是所有集合框架的父接口：</p>
<p>Collection接口的子接口包括：Set接口和List接口<br>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等<br>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等<br>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</p>
<h3 id="1-Collection-接口"><a href="#1-Collection-接口" class="headerlink" title="1.Collection 接口"></a>1.Collection 接口</h3><p>用于表示任何对象或元素组。想要尽可能以常规方式处理一组元素时，就使用这一接口。 </p>
<h4 id="1-单元素添加、删除操作："><a href="#1-单元素添加、删除操作：" class="headerlink" title="(1) 单元素添加、删除操作："></a>(1) 单元素添加、删除操作：</h4><p>boolean add(Object o):        将对象添加给集合 </p>
<p>boolean remove(Object o):  如果集合中有与o相匹配的对象，则删除对象o </p>
<h4 id="2-查询操作："><a href="#2-查询操作：" class="headerlink" title="(2) 查询操作："></a>(2) 查询操作：</h4><p>int size() ：           返回当前集合中元素的数量 </p>
<p>boolean isEmpty() ：               判断集合中是否有任何元素 </p>
<p>boolean contains(Object o) ：查找集合中是否含有对象o </p>
<p>Iterator iterator() ：返回一个迭代器，用来访问集合中的各个元素 </p>
<h4 id="3-组操作-：作用于元素组或整个集合"><a href="#3-组操作-：作用于元素组或整个集合" class="headerlink" title="(3) 组操作 ：作用于元素组或整个集合"></a>(3) 组操作 ：作用于元素组或整个集合</h4><p>boolean containsAll(Collection c): 查找集合中是否含有集合c 中所有元素 </p>
<p>boolean addAll(Collection c) : 将集合c 中所有元素添加给该集合 </p>
<p>void clear(): 删除集合中所有元素 </p>
<p>void removeAll(Collection c) : 从集合中删除集合c 中的所有元素 </p>
<p>void retainAll(Collection c) : 从集合中删除集合c 中不包含的元素 </p>
<h4 id="4-Collection转换为Object数组-："><a href="#4-Collection转换为Object数组-：" class="headerlink" title="(4) Collection转换为Object数组 ："></a>(4) Collection转换为Object数组 ：</h4><p>Object[] toArray() ：返回一个内含集合所有元素的array </p>
<p>Object[] toArray(Object[] a) ：返回一个内含集合所有元素的array。运行期返回的array<br>和参数a的型别相同，需要转换为正确型别。 </p>
<p>此外，您还可以把集合转换成其它任何其它的对象数组。但是，您不能直接把集合转换成基本<br>数据类型的数组，因为集合必须持有对象。 </p>
<p>Collection不提供get()方法。如果要遍历Collectin中的元素，就必须用Iterator。</p>
<h3 id="1-2-Iterator-接口"><a href="#1-2-Iterator-接口" class="headerlink" title="1.2.Iterator 接口"></a>1.2.Iterator 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"><span class="keyword">while</span>(it. hasNext())&#123;</span><br><span class="line">  String obj = it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Collection 接口的iterator()方法返回一个 Iterator。Iterator接口方法能以迭代方式逐<br>个访问集合中各个元素，并安全的从Collection 中除去适当的元素。 </p>
<p>(1) boolean hasNext(): 判断是否存在另一个可访问的元素 </p>
<p>Object next(): 返回要访问的下一个元素。如果到达集合结尾，则抛出<br>NoSuchElementException异常。 </p>
<p>(2) void remove(): 删除上次访问返回的对象。本方法必须紧跟在一个元素的访问后执行。<br>如果上次访问后集合已被修改，方法将抛出IllegalStateException。 </p>
<p>“Iterator中删除操作对底层Collection也有影响。</p>
<blockquote>
<p>如何边遍历边移除 Collection 中的元素？</p>
</blockquote>
<p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">   <span class="comment">// do something</span></span><br><span class="line">   it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一种最常见的<strong>错误</strong>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line">   list.remove(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以上错误代码会报 ConcurrentModificationException 异常。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p>
<p>迭代器是 故障快速修复（fail-fast）的。这意味着，当另一个线程修改底层集合的时候，如<br>果您正在用 Iterator 遍历集合，那么，Iterator就会抛出<br>ConcurrentModificationException （另一种 RuntimeException异常）异常并立刻失败 </p>
<h3 id="2-List接口"><a href="#2-List接口" class="headerlink" title="2.  List接口"></a>2.  List接口</h3><p>List 接口继承了 Collection 接口。</p>
<p><strong>特点</strong>：有序，有下标，元素可以重复。 </p>
<p>实现类：</p>
<p>ArrayList : 主要实现类，能解决80%的需求；数组结构存储(长度可变)，查询快，增删慢；操作速度快，并发效率高，线程不安全；</p>
<p>LinkedList : 链表结构存储(集合中持有多个Node,Node中item存个人数据)，额外提供“列头”和“列尾”统一方法；查询慢，增删快，更适用于频繁的插入、删除操作；</p>
<p>Vector : 古老的实现类，数组结构存储(长度可变)，查询快，增删慢，线程安全；</p>
<p>void add(int index, Object element):   在指定位置index上添加元素element </p>
<p>boolean addAll(int index, Collection c):   将集合c的所有元素添加到指定位置index </p>
<p>Object get(int index):   返回List中指定位置的元素 </p>
<p>int indexOf(Object o):   返回第一个出现元素o的位置，否则返回-1 </p>
<p>int lastIndexOf(Object o) ：返回最后一个出现元素o的位置，否则返回-1 </p>
<p>Object remove(int index) ：删除指定位置上的元素 </p>
<p>Object set(int index, Object element) ：用元素element取代位置index上的元素，并且<br>返回旧的元素 </p>
<p>(2) List 接口不但以位置序列迭代的遍历整个列表，还能处理集合的子集： </p>
<p>ListIterator listIterator() : 返回一个列表迭代器，用来访问列表中的元素 </p>
<p>ListIterator listIterator(int index) : 返回一个列表迭代器，用来从指定位置index开<br>始访问列表中的元素 </p>
<h4 id="如何实现数组和-List-之间的转换？"><a href="#如何实现数组和-List-之间的转换？" class="headerlink" title="如何实现数组和 List 之间的转换？"></a>如何实现数组和 List 之间的转换？</h4><ul>
<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>
<li>List 转数组：使用 List 自带的 toArray() 方法。</li>
</ul>
<h3 id="2-1-ListIterator接口"><a href="#2-1-ListIterator接口" class="headerlink" title="2.1.ListIterator接口"></a>2.1.ListIterator接口</h3><p>ListIterator 接口继承 Iterator 接口以支持添加或更改底层集合中的元素，还支持双向访<br>问。ListIterator没有当前位置，光标位于调用previous和next方法返回的值之间。一个<br>长度为n的列表，有n+1个有效索引值： </p>
<p>(1) void add(Object o):         将对象o添加到当前位置的前面 </p>
<p>void set(Object o):             用对象o替代next或previous方法访问的上一个元素。</p>
<p>(2) boolean hasPrevious():      判断向后迭代时是否有元素可访问 </p>
<p>Object previous()：        返回上一个对象 </p>
<p>int nextIndex():               返回下次调用next方法时将返回的元素的索引 </p>
<p>int previousIndex():          返回下次调用previous方法时将返回的元素的索引 </p>
<blockquote>
<p>Iterator 和 ListIterator 有什么区别？</p>
</blockquote>
<p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</p>
<p>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</p>
<p>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p>
<h3 id="2-3-1-LinkedList类"><a href="#2-3-1-LinkedList类" class="headerlink" title="2.3.1. LinkedList类"></a>2.3.1. LinkedList类</h3><table>
<thead>
<tr>
<th>ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td>底层是数组结构</td>
<td>底层是链表结构</td>
</tr>
<tr>
<td>适合多查询，少插入删除元素</td>
<td>适合多插入，删除元素，少查询操作</td>
</tr>
<tr>
<td>有序</td>
<td>有序</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//为了方便取出LinkedList的第一个元素</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">//为了方便取出LinkedList的最后一个元素</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">		<span class="comment">//元素的值</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">//指向后一个元素</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        <span class="comment">//指向前一个元素</span></span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从以上源码可以看出，LinkedList底层是链表结构，每个元素都是一个Node，里面包括本身元素的值和指向前后元素的指针 </p>
</blockquote>
<p><strong>方法名         作用</strong><br>getFirst()     获取第一个元素<br>peek()             获取第一个元素<br>getLast()     获取最后一个元素<br>removeFirst()     移除第一个元素<br>poll()                     移除第一个元素<br>removeLast()     移除最后一个元素<br>addFirst(E e)             在集合的头部插入元素<br>push(E e)             在集合的头部插入元素<br>addLast(E e)      在集合的尾部添加元素</p>
<h3 id="2-3-2-ArrayList类"><a href="#2-3-2-ArrayList类" class="headerlink" title="2.3.2. ArrayList类"></a>2.3.2. ArrayList类</h3><p><strong>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</strong></p>
<p>遍历方式有以下几种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</span><br><span class="line"></span><br><span class="line">迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</span><br><span class="line"></span><br><span class="line">foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</span><br></pre></td></tr></table></figure>

<p>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p>
<p><strong>ArrayList的优点如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</span><br><span class="line">ArrayList 在顺序添加一个元素的时候非常方便。</span><br></pre></td></tr></table></figure>

<p><strong>ArrayList 的缺点如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</span><br><span class="line">插入元素的时候，也需要做一次元素复制操作，缺点同上。</span><br></pre></td></tr></table></figure>

<p>ArrayList 比较适合顺序添加、随机访问的场景。</p>
<p><strong>ArrayList 和 LinkedList 的区别是什么？</strong></p>
<p>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。<br>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。<br>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全</p>
<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>
<p><strong>ArrayList 和 Vector 的区别是什么？</strong></p>
<p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合</p>
<p>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。<br>性能：ArrayList 在性能方面要优于 Vector。<br>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p>
<p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p>
<p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p>
<p><strong>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</strong></p>
<p>ArrayList、LinkedList、Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</p>
<p>Vector 中的方法由于加了 synchronized 修饰，因此 Vector 是线程安全容器，但性能上较ArrayList差。</p>
<p>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 LinkedList 插入速度较快。</p>
<p><strong>多线程场景下如何使用 ArrayList？</strong></p>
<p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">synchronizedList.add(<span class="string">"aaa"</span>);</span><br><span class="line">synchronizedList.add(<span class="string">"bbb"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; synchronizedList.size(); i++) &#123;</span><br><span class="line">    System.out.println(synchronizedList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Array 和 ArrayList 有何区别？</strong></p>
<p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。<br>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p>
<h3 id="3-Set接口"><a href="#3-Set接口" class="headerlink" title="3.Set接口"></a>3.Set接口</h3><p>实现类：</p>
<p>HashSet : 是主要实现类，存储结构：链表数组；保证重复对象只有一个；</p>
<p>LinkedHashSet(是HashSet的子类，当我们遍历集合元素时，是按照添加进去的顺序实现的；频繁的遍历，较少的添加、插入操作 建议选择此)</p>
<p>TreeSet（可以按照添加进集合中的元素的指定属性进行排序），要求TreeSet添加进的元素必须是同一个类的！</p>
<p><strong>说一下 HashSet 的实现原理？</strong></p>
<p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>
<p><strong>List 和 Set 的区别</strong></p>
<p>List , Set 都是继承自Collection 接口</p>
<p>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</p>
<p>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</p>
<p>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</p>
<p><strong>Set和List对比</strong></p>
<p>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</p>
<p><strong>hashCode（）与equals（）的相关规定：</strong></p>
<ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个equals方法返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
</ol>
<p>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖<br>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p>
<p><strong>==与equals的区别</strong></p>
<ol>
<li>==是判断两个变量或实例是不是指向同一个内存空间  equals是判断两个变量或实例所指向的内存空间的值是不是相同</li>
<li>==是指对内存地址进行比较  equals()是对字符串的内容进行比较</li>
<li>==指引用是否相同  equals()指的是值是否相同</li>
</ol>
<h4 id="HashSet与HashMap的区别"><a href="#HashSet与HashMap的区别" class="headerlink" title="HashSet与HashMap的区别"></a>HashSet与HashMap的区别</h4><table>
<thead>
<tr>
<th>HashMap</th>
<th align="left">HashSet</th>
</tr>
</thead>
<tbody><tr>
<td>实现了Map接口</td>
<td align="left">实现Set接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td align="left">仅存储对象</td>
</tr>
<tr>
<td>调用put（）向map中添加元素</td>
<td align="left">调用add（）方法向Set中添加元素</td>
</tr>
<tr>
<td>HashMap使用键（Key）计算Hashcode</td>
<td align="left">HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td>
</tr>
<tr>
<td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td>
<td align="left">HashSet较HashMap来说比较慢</td>
</tr>
</tbody></table>
<h3 id="3-1-Hash表"><a href="#3-1-Hash表" class="headerlink" title="3.1. Hash表"></a>3.1. Hash表</h3><p>Hash表是一种数据结构，用来查找对象。Hash表为每个对象计算出一个整数，称为Hash<br>Code(哈希码)。Hash表是个链接式列表的阵列。每个列表称为一个buckets(哈希表元)。对象<br>位置的计算 index = HashCode % buckets (HashCode为对象哈希码，buckets为哈希表元总<br>数)。 </p>
<p>当你添加元素时，有时你会遇到已经填充了元素的哈希表元，这种情况称为Hash<br>Collisions(哈希冲突)。这时，你必须判断该元素是否已经存在于该哈希表中。 </p>
<p>如果哈希码是合理地随机分布的，并且哈希表元的数量足够大，那么哈希冲突的数量就会减少。<br>同时，你也可以通过设定一个初始的哈希表元数量来更好地控制哈 希表的运行。初始哈希表<br>元的数量为 buckets = size * 150% + 1 (size为预期元素的数量)。 </p>
<p>如果哈希 表中的元素放得太满，就必须进行rehashing(再哈希)。再哈希使哈希表元数增倍，<br>并将原有的对象重新导入新的哈希表元中，而原始的哈希表元被删 除。load factor(加载因<br>子)决定何时要对哈希表进行再哈希。在Java编程语言中，加载因子默认值为0.75，默认哈<br>希表元为101。 </p>
<h3 id="3-2-Comparable接口和Comparator接口"><a href="#3-2-Comparable接口和Comparator接口" class="headerlink" title="3.2. Comparable接口和Comparator接口"></a>3.2. Comparable接口和Comparator接口</h3><p><strong>Comparable接口和Comparator接口的区别</strong></p>
<p>Comparable接口位于java.lang包下；Comparator位于java.util包下<br>Comparable接口只提供了一个compareTo()方法；Comparator接口不仅提供了compara()方法，还提供了其他默认方法，如reversed()、thenComparing()，使我们可以按照更多的方式进行排序<br>如果要用Comparable接口，则必须实现这个接口，并重写comparaTo()方法；但是Comparator接口可以在类外部使用，通过将该接口的一个匿名类对象当做参数传递给Collections.sort()方法或者Arrays.sort()方法实现排序。Comparator体现了一种策略模式，即可以不用要把比较方法嵌入到类中，而是可以单独在类外部使用，这样我们就可有不用改变类本身的代码而实现对类对象进行排序。</p>
<h4 id="3-2-1-Comparable接口"><a href="#3-2-1-Comparable接口" class="headerlink" title="3.2.1. Comparable接口"></a>3.2.1. Comparable接口</h4><p>在java.lang包中，Comparable接口适用于一个类有自然顺序的时候。假定对象集合是同一<br>类型，该接口允许您把集合排序成自然顺序。 </p>
<p>(1) int compareTo(Object o): 比较当前实例对象与对象o，如果位于对象o之前，返回负<br>值，如果两个对象在排序中位置相同，则返回0，如果位于对象o后面，则返回正值 </p>
<h4 id="3-2-2-Comparator接口"><a href="#3-2-2-Comparator接口" class="headerlink" title="3.2.2. Comparator接口"></a>3.2.2. Comparator接口</h4><p>若一个类不能用于实现java.lang.Comparable，或者您不喜欢缺省的Comparable行为并想提<br>供自己的排序顺序(可能多种排序方式)，你可以实现Comparator接口，从而定义一个比较器。 </p>
<p>(1)int compare(Object o1, Object o2): 对两个对象o1和o2进行比较，如果o1位于o2<br>的前面，则返回负值，如果在排序顺序中认为o1和o2是相同的，返回0，如果o1位于o2的<br>后面，则返回正值 </p>
<p>“与Comparable相似，0返回值不表示元素相等。一个0返回值只是表示两个对象排在同一<br>位置。由Comparator用户决定如何处理。如果两个不相等的元素比较的结果为零，您首先应<br>该确信那就是您要的结果，然后记录行为。” </p>
<p>(2)boolean equals(Object obj): 指示对象obj是否和比较器相等。 </p>
<p>“该方法覆写Object的equals()方法，检查的是Comparator实现的等同性，不是处于比较<br>状态下的对象。” </p>
<h3 id="3-3-SortedSet接口"><a href="#3-3-SortedSet接口" class="headerlink" title="3.3. SortedSet接口"></a>3.3. SortedSet接口</h3><p>“集合框架”提供了个特殊的Set接口：SortedSet，它保持元素的有序顺序。SortedSet接<br>口为集的视图(子集)和它的两端（即头和尾） 提供了访问方法。当您处理列表的子集时，更<br>改视图会反映到源集。此外，更改源集也会反映在子集上。发生这种情况的原因在于视图由两<br>端的元素而不是下标元素 指定，所以如果您想要一个特殊的高端元素（toElement）在子集中，<br>您必须找到下一个元素。 </p>
<p>添加到SortedSet实现类的元素必须实现Comparable接口，否则您必须给它的构造函数提供<br>一个Comparator接口的实现。TreeSet类是它的唯一一份实现。 </p>
<p>“因为集必须包含唯一的项，如果添加元素时比较两个元素导致了0返回值（通过Comparable<br>的compareTo()方法或Comparator 的compare()方法），那么新元素就没有添加进去。如果<br>两个元素相等，那还好。但如果它们不相等的话，您接下来就应该修改比较方法，让比较方法<br>和 equals() 的效果一致。” </p>
<p>(1) Comparator comparator(): 返回对元素进行排序时使用的比较器，如果使用Comparable<br>接口的compareTo()方法对元素进行比较，则返回null </p>
<p>(2) Object first(): 返回有序集合中第一个(最低)元素 </p>
<p>(3) Object last(): 返回有序集合中最后一个(最高)元素 </p>
<p>(4) SortedSet subSet(Object fromElement, Object toElement): 返回从fromElement(包<br>括)至toElement(不包括)范围内元素的SortedSet视图(子集) </p>
<p>(5) SortedSet headSet(Object toElement): 返回SortedSet的一个视图，其内各元素皆小<br>于toElement </p>
<p>(6) SortedSet tailSet(Object fromElement): 返回SortedSet的一个视图，其内各元素皆<br>大于或等于fromElement </p>
<h3 id="3-5-1-HashSet类"><a href="#3-5-1-HashSet类" class="headerlink" title="3.5.1.HashSet类"></a>3.5.1.HashSet类</h3><p>对于 HashSet 而言，它是基于 HashMap 实现的，HashSet 底层采用 HashMap 来保存所有元素，因此 HashSet 的实现比较由上面源程序可以看出，HashSet 的实现其实非常简单，它只是封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的<br>Object 对象。 </p>
<p>HashSet 的绝大部分方法都是通过调用 HashMap 的方法来实现的，因此 HashSet 和 HashMap 两个集合在实现本质上是相同  的。  </p>
<ol>
<li><strong>不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化。</strong></li>
<li><strong>HashSet不是同步的，如果多个线程同时访问一个HashSet，必须通过代码来保证其同步。</strong></li>
<li><strong>集合元素可以是null。</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHashSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">  set.add(<span class="string">"one"</span>);</span><br><span class="line">  set.add(<span class="string">"two"</span>);</span><br><span class="line">  set.add(<span class="string">"three"</span>);</span><br><span class="line">  </span><br><span class="line">  Iterator it = set.iterator();</span><br><span class="line">  <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">   System.out.println(it.next());</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-2-TreeSet类"><a href="#3-5-2-TreeSet类" class="headerlink" title="3.5.2. TreeSet类"></a>3.5.2. TreeSet类</h3><ol>
<li><p>TreeSet是SortedSet接口的唯一实现, TreeSet可以确保集合元素处于排序状态.  TreeSet并不是根据元素的插入顺序进行排序,而是根据元素实际值来进行排序.(可以确保元素唯一并且元素排序)  TreeSet采用红黑树的数据结构对元素进行排序.</p>
</li>
<li><p>TreeSet支持两种排序方法:  自然排序和比较器排序.  默认情况下,TreeSet 采用自然排序.(Integer类型元素自然升序) </p>
</li>
<li><p>自然排序:</p>
<p> TreeSet会调用元素的compareTo(Object obj)方法来比较元素之间大小关系, 然后将集合元素按升序排序,这就是自然排序.</p>
<p> Java提供了一个comparable接口, 该接口里定义了一个compareTo(Object obj)方法, 该方法返回一个整数值,实现该接口的类必须实现该方法,实现了该接口的类的对象就可以比较大小了</p>
<p>当一个对象调用该方法与另一个对象进行比较, 例: obj.compareTo(obj2) ,如果该方法返回0, 则这两个对象相等,  返回一个正整数则说明obj大于obj2;  返回一个负整数,则说明 obj小于obj2.</p>
<p>6.比较器排序</p>
<p>TreeSet的构造方式不同,排序的方式也不同.</p>
<p>比较器排序:  public TreeSet(Comparator<E> comparator)</p>
<p>两种方式:</p>
<p>1)自定义一个类,该类实现Comparator接口,重写Comparator接口中的compare()方法</p>
<p> 2)直接使用接口匿名内部类的方式实现                                    </p>
</li>
</ol>
<h3 id="4-Map接口"><a href="#4-Map接口" class="headerlink" title="4. Map接口"></a>4. Map接口</h3><p>Map接口不是Collection接口的继承。Map接口用于维护键/值对(key/value pairs)。该接口<br>描述了从不重复的键到值的映射。 </p>
<p> 主要实现类：</p>
<p><strong>HashMap</strong> ：是主要的实现类，允许用null值作为key和value；底层存储：数组+链表；操作速度快，线程不安全；</p>
<p><strong>说一下 HashMap 的实现原理？</strong></p>
<p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p>HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>
<p>HashMap 基于 Hash 算法实现的</p>
<p>当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标存储时，如果出现hash值相同的key，此时有两种情况。</p>
<p>(1)如果key相同，则覆盖原始值；</p>
<p>(2)如果key不同（出现冲突），则将当前的key-value放入链表中<br>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。<br>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p>
<p>需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</p>
<p><strong>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</strong></p>
<p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突。<br><strong>JDK1.8之前</strong></p>
<p><img src="/Y960303802.github.io/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/Y960303802/image/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/12.png"  alt=""></p>
<p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p>jdk1.7中HashMap数据结构<br><strong>JDK1.8之后</strong></p>
<p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><img src="/Y960303802.github.io/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/Y960303802/image/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/13.png"  alt=""></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">pros.load(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"jdbc.properties"</span>)));</span><br><span class="line">String user = pros.getProperty(<span class="string">"user"</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line">String password = pros.getProperty(<span class="string">"password"</span>);</span><br><span class="line">System.out.println(password);</span><br></pre></td></tr></table></figure>

<p><strong>TreeMap</strong>：实现了SortedMap接口，自动对key排序，key作为对象，必须实现Comparable接口；需要按照key所在类的指定属性进行排序，要求key是同一个类的对象。</p>
<h4 id="JDK1-7-VS-JDK1-8-比较"><a href="#JDK1-7-VS-JDK1-8-比较" class="headerlink" title="JDK1.7 VS JDK1.8 比较"></a>JDK1.7 VS JDK1.8 比较</h4><p>JDK1.8主要解决或优化了一下问题：</p>
<ol>
<li>resize 扩容优化</li>
<li>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</li>
<li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li>
</ol>
<table>
<thead>
<tr>
<th>不同</th>
<th>JDK 1.7</th>
<th>JDK 1.8</th>
</tr>
</thead>
<tbody><tr>
<td>存储结构</td>
<td>数组 + 链表</td>
<td>数组 + 链表 + 红黑树</td>
</tr>
<tr>
<td>初始化方式</td>
<td>单独函数：<code>inflateTable()</code></td>
<td>直接集成到了扩容函数<code>resize()</code>中</td>
</tr>
<tr>
<td>hash值计算方式</td>
<td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td>
<td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td>
</tr>
<tr>
<td>存放数据的规则</td>
<td>无冲突时，存放数组；冲突时，存放链表</td>
<td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td>
</tr>
<tr>
<td>插入数据方式</td>
<td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td>
<td>尾插法（直接插入到链表尾部/红黑树）</td>
</tr>
<tr>
<td>扩容后存储位置的计算方式</td>
<td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td>
<td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td>
</tr>
</tbody></table>
<p><strong>为什么HashMap中String、Integer这样的包装类适合作为K？</strong></p>
<p>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>
<p>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况<br>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</p>
<p><strong>HashMap 与 HashTable 有什么区别？</strong></p>
<p><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；<br><strong>效率</strong>： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；<br><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。<br><strong>初始容量大小和每次扩充容量大小的不同 *<em>： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。<br>*</em>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
<p>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p>
<p><strong>LinkedHashMap</strong>：是HashMap的子类，可以按照添加进Map的顺序实现遍历</p>
<p><strong>Hashtable</strong> : 是一个古老的实现类，线程安全的,不允许用null值作为key或者value；</p>
<p>Hashtable的子类：<strong>Properties</strong>：常用来处理属性文件，key和value都是String类型的。使用方法：setProperty(String key,String value) ; getProperty(String key)</p>
<h4 id="Properties的使用"><a href="#Properties的使用" class="headerlink" title="Properties的使用"></a>Properties的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">pros.load(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"jdbc.properties"</span>)));</span><br><span class="line">String user = pros.getProperty(<span class="string">"user"</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line">String password = pros.getProperty(<span class="string">"password"</span>);</span><br><span class="line">System.out.println(password);</span><br></pre></td></tr></table></figure>



<p><strong>TreeMap</strong>：实现了SortedMap接口，自动对key排序，key作为对象，必须实现Comparable接口；需要按照key所在类的指定属性进行排序，要求key是同一个类的对象。</p>
<p>(1) 添加、删除操作： </p>
<p>Object put(Object key, Object value): 将互相关联的一个关键字与一个值放入该映像。如<br>果该关键字已经存在，那么与此关键字相关的新值将取代旧值。方法返回关键字的旧值，如果<br>关键字原先并不存在，则返回null </p>
<p>Object remove(Object key): 从映像中删除与key相关的映射 </p>
<p>void putAll(Map t): 将来自特定映像的所有元素添加给该映像 </p>
<p>void clear(): 从映像中删除所有映射 </p>
<p>“键和值都可以为null。但是，您不能把Map作为一个键或值添加给自身。” </p>
<p>(2) 查询操作： </p>
<p>Object get(Object key): 获得与关键字key相关的值，并且返回与关键字key相关的对象，<br>如果没有在该映像中找到该关键字，则返回null </p>
<p>boolean containsKey(Object key): 判断映像中是否存在关键字key </p>
<p>boolean containsValue(Object value): 判断映像中是否存在值value </p>
<p>int size(): 返回当前映像中映射的数量 </p>
<p>boolean isEmpty() ：判断映像中是否有任何映射 </p>
<p>(3) 视图操作 ：处理映像中键/值对组 </p>
<p>Set keySet(): 返回映像中所有关键字的视图集 </p>
<p>“因为映射中键的集合必须是唯一的，您用Set支持。你还可以从视图中删除元素，同时，关<br>键字和它相关的值将从源映像中被删除，但是你不能添加任何元素。” </p>
<p>Collection values():返回映像中所有值的视图集 </p>
<p>“因为映射中值的集合不是唯一的，您用Collection支持。你还可以从视图中删除元素，同<br>时，值和它的关键字将从源映像中被删除，但是你不能添加任何元素。” </p>
<p>Set entrySet(): 返回Map.Entry对象的视图集，即映像中的关键字/值对 </p>
<p>“因为映射是唯一的，您用Set支持。你还可以从视图中删除元素，同时，这些元素将从源映<br>像中被删除，但是你不能添加任何元素。” </p>
<h4 id="4-4-1-HashMap类"><a href="#4-4-1-HashMap类" class="headerlink" title="4.4.1. HashMap类"></a>4.4.1. HashMap类</h4><p>为了优化HashMap空间的使用，您可以调优初始容量和负载因子。 </p>
<p>(1) HashMap(): 构建一个空的哈希映像 </p>
<p>(2) HashMap(Map m): 构建一个哈希映像，并且添加映像m的所有映射 </p>
<p>(3) HashMap(int initialCapacity): 构建一个拥有特定容量的空的哈希映像 </p>
<p>(4) HashMap(int initialCapacity, float loadFactor): 构建一个拥有特定容量和加载因子<br>的空的哈希映像 </p>
<h4 id="4-4-2-TreeMap类"><a href="#4-4-2-TreeMap类" class="headerlink" title="4.4.2. TreeMap类"></a>4.4.2. TreeMap类</h4><p>TreeMap没有调优选项，因为该树总处于平衡状态。 </p>
<p>(1) TreeMap():构建一个空的映像树 </p>
<p>(2) TreeMap(Map m): 构建一个映像树，并且添加映像m中所有元素 </p>
<p>(3) TreeMap(Comparator c): 构建一个映像树，并且使用特定的比较器对关键字进行排序 </p>
<p>(4) TreeMap(SortedMap s): 构建一个映像树，添加映像树s中所有映射，并且使用与有序映<br>像s相同的比较器排序 </p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">戏子</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.yinpeng.fun/2020/05/05/JavaSE%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/">https://www.yinpeng.fun/2020/05/05/JavaSE%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.yinpeng.fun" target="_blank">戏子</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/Y960303802.github.io/tags/JavaSE/">JavaSE</a></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/Y960303802.github.io/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/Y960303802.github.io/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/Y960303802.github.io/2020/05/11/Vue%E5%AD%A6%E4%B9%A0/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/Y960303802/image/img2/570566.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Vue学习</div></div></a></div><div class="next-post pull_right"><a href="/Y960303802.github.io/2020/05/05/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/Y960303802/image/img2/719179.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java中的反射与注解</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/Y960303802.github.io/2020/05/05/Java中的反射与注解/" title="Java中的反射与注解"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/Y960303802/image/img2/719179.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-05</div><div class="relatedPosts_title">Java中的反射与注解</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/Y960303802/image/img2/549450.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By 戏子</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener"><img class="icp-icon" src="/Y960303802.github.io/img/icp.png"/><span>赣ICP备20003959号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/Y960303802.github.io/js/utils.js"></script><script src="/Y960303802.github.io/js/main.js"></script><script src="/Y960303802.github.io/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/Y960303802.github.io/js/third-party/fireworks.js"></script><script defer id="ribbon" src="/Y960303802.github.io/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/Y960303802.github.io/js/search/local-search.js"></script></body></html>