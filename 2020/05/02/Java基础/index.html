<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java基础 | 戏子</title><meta name="description" content="Java基础"><meta name="keywords" content="Java基础"><meta name="author" content="戏子"><meta name="copyright" content="戏子"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Y960303802/image/titile.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java基础"><meta name="twitter:description" content="Java基础"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Y960303802/image/img2/1053126.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Java基础"><meta property="og:url" content="https://www.yinpeng.fun/2020/05/02/Java%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="戏子"><meta property="og:description" content="Java基础"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Y960303802/image/img2/1053126.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/Y960303802.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://www.yinpeng.fun/2020/05/02/Java%E5%9F%BA%E7%A1%80/"><link rel="next" title="线程池" href="https://www.yinpeng.fun/2020/05/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/Y960303802.github.io/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/Y960303802.github.io/atom.xml" title="戏子" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/Y960303802/image/titile.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/Y960303802.github.io/archives/"><div class="headline">文章</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/Y960303802.github.io/tags/"><div class="headline">标签</div><div class="length_num">9</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/Y960303802.github.io/categories/"><div class="headline">分类</div><div class="length_num">20</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-什么是JVM？什么是JDK？-什么是JRE？"><span class="toc-number">1.</span> <span class="toc-text">4. 什么是JVM？什么是JDK？ 什么是JRE？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM"><span class="toc-number">1.1.</span> <span class="toc-text">JVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JRE"><span class="toc-number">1.2.</span> <span class="toc-text">JRE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK"><span class="toc-number">1.3.</span> <span class="toc-text">JDK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Java三种注释类型"><span class="toc-number">2.</span> <span class="toc-text">5. Java三种注释类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-八种基本数据类型及其字节数"><span class="toc-number">3.</span> <span class="toc-text">6. 八种基本数据类型及其字节数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-i-和-i的异同之处"><span class="toc-number">4.</span> <span class="toc-text">7. i++和++i的异同之处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-amp-和-amp-amp-和-的区别和联系"><span class="toc-number">5.</span> <span class="toc-text">8. &amp;和&amp;&amp; , |和|| 的区别和联系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-用最有效率的方法算出2乘以8等于多少"><span class="toc-number">6.</span> <span class="toc-text">9. 用最有效率的方法算出2乘以8等于多少</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-基本数据类型的类型转换规则"><span class="toc-number">7.</span> <span class="toc-text">10. 基本数据类型的类型转换规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-if和switch的异同之处"><span class="toc-number">8.</span> <span class="toc-text">11.  if和switch的异同之处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-while和do-while循环的区别"><span class="toc-number">9.</span> <span class="toc-text">12.  while和do-while循环的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-break和continue的作用"><span class="toc-number">10.</span> <span class="toc-text">13.  break和continue的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-请使用递归算法计算n！"><span class="toc-number">11.</span> <span class="toc-text">14.  请使用递归算法计算n！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-递归的定义和优缺点"><span class="toc-number">12.</span> <span class="toc-text">15. 递归的定义和优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-数组的特征"><span class="toc-number">13.</span> <span class="toc-text">16. 数组的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-可变参数的作用和特点"><span class="toc-number">14.</span> <span class="toc-text">20. 可变参数的作用和特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-面向过程和面向对象的区别"><span class="toc-number">15.</span> <span class="toc-text">22. 面向过程和面向对象的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-this和super关键字的作用"><span class="toc-number">16.</span> <span class="toc-text">23. this和super关键字的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-final、finally、finalize的区别"><span class="toc-number">17.</span> <span class="toc-text">26. final、finally、finalize的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-写出java-lang-Object类的六个常用方法"><span class="toc-number">18.</span> <span class="toc-text">27. 写出java.lang.Object类的六个常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-权限修饰符的区别"><span class="toc-number">19.</span> <span class="toc-text">28. 权限修饰符的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-继承条件下构造方法的执行过程"><span class="toc-number">20.</span> <span class="toc-text">29. 继承条件下构造方法的执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-和equals的区别和联系"><span class="toc-number">21.</span> <span class="toc-text">30. &#x3D;&#x3D;和equals的区别和联系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-谈谈Java的多态"><span class="toc-number">22.</span> <span class="toc-text">31. 谈谈Java的多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-简述Java的垃圾回收机制"><span class="toc-number">23.</span> <span class="toc-text">32. 简述Java的垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-基本数据类型和包装类"><span class="toc-number">24.</span> <span class="toc-text">33. 基本数据类型和包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-Integer与int的区别"><span class="toc-number">25.</span> <span class="toc-text">34. Integer与int的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-java-sql-Date和java-util-Date的联系和区别"><span class="toc-number">26.</span> <span class="toc-text">35. java.sql.Date和java.util.Date的联系和区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-递归应用题"><span class="toc-number">27.</span> <span class="toc-text">36. 递归应用题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java程序中如何检测？如何解决？"><span class="toc-number">28.</span> <span class="toc-text">47. 说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java程序中如何检测？如何解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？"><span class="toc-number">29.</span> <span class="toc-text">48. 什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-不通过构造函数也能创建对象吗？"><span class="toc-number">30.</span> <span class="toc-text">49. 不通过构造函数也能创建对象吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-匿名内部类可不可以继承或实现接口。为什么？"><span class="toc-number">31.</span> <span class="toc-text">50. 匿名内部类可不可以继承或实现接口。为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型"><span class="toc-number">32.</span> <span class="toc-text">51. 在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-简述Java中如何实现多态"><span class="toc-number">33.</span> <span class="toc-text">52. 简述Java中如何实现多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-以下对继承的描述锚误的是"><span class="toc-number">34.</span> <span class="toc-text">53. 以下对继承的描述锚误的是 ()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-Java-中-Math-random（）-Math-random（）值为？"><span class="toc-number">35.</span> <span class="toc-text">54. Java 中 Math.random（）&#x2F;Math.random（）值为？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-Java中，如果Manager是Employee的子类，那么-Pair-是-Pair"><span class="toc-number">36.</span> <span class="toc-text">55. Java中，如果Manager是Employee的子类，那么 Pair  是 Pair</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-接口和抽象类的区别"><span class="toc-number">37.</span> <span class="toc-text">56. 接口和抽象类的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-同步代码块和同步方法有什么区别"><span class="toc-number">38.</span> <span class="toc-text">57. 同步代码块和同步方法有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-静态内部类和内部类有什么区别"><span class="toc-number">39.</span> <span class="toc-text">58. 静态内部类和内部类有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-反射的概念与作用"><span class="toc-number">40.</span> <span class="toc-text">59. 反射的概念与作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-下列哪一种叙述是正确的"><span class="toc-number">41.</span> <span class="toc-text">63. 下列哪一种叙述是正确的()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-下列语句正确的是"><span class="toc-number">42.</span> <span class="toc-text">64. 下列语句正确的是()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-存在使i-1-lt-i的数么"><span class="toc-number">43.</span> <span class="toc-text">78. 存在使i+1&lt;i的数么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79-接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？"><span class="toc-number">44.</span> <span class="toc-text">79. 接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85-Class类的getDeclaredFields-方法与getFields-的区别？"><span class="toc-number">45.</span> <span class="toc-text">85. Class类的getDeclaredFields()方法与getFields()的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#89-请解释以下常用正则含义："><span class="toc-number">46.</span> <span class="toc-text">89. 请解释以下常用正则含义：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-什么是编译型语言，什么是解释型语言？java可以归类到那种？"><span class="toc-number">47.</span> <span class="toc-text">101. 什么是编译型语言，什么是解释型语言？java可以归类到那种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#116-Java中byte表示的数值范围是什么？"><span class="toc-number">48.</span> <span class="toc-text">116. Java中byte表示的数值范围是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#117-如何将日期类型格式化为：2013-02-18-10-53-10？"><span class="toc-number">49.</span> <span class="toc-text">117.如何将日期类型格式化为：2013-02-18 10:53:10？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#以下Java代码段会产生几个对象"><span class="toc-number">50.</span> <span class="toc-text">以下Java代码段会产生几个对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122-Math-round（-11-2）的运行结果是。"><span class="toc-number">51.</span> <span class="toc-text">\122. Math.round（-11.2）的运行结果是。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124-Java中int-long占用的字节数分别是"><span class="toc-number">52.</span> <span class="toc-text">124. Java中int,long占用的字节数分别是</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#125-System-out-println-‘a’-1-的结果是"><span class="toc-number">53.</span> <span class="toc-text">125. System.out.println(‘a’+1);的结果是</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#131-成员变量用static修饰和不用static修饰有什么区别？"><span class="toc-number">54.</span> <span class="toc-text">131. 成员变量用static修饰和不用static修饰有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#132-如果变量用fifinal修饰，则怎样？如果方法fifinal修饰，则怎样？"><span class="toc-number">55.</span> <span class="toc-text">132. 如果变量用fifinal修饰，则怎样？如果方法fifinal修饰，则怎样？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#145-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><span class="toc-number">56.</span> <span class="toc-text">145. 两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#147-重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分"><span class="toc-number">57.</span> <span class="toc-text">147.重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#148-华为的面试题中曾经问过这样一个问题：为什么不能根据返回类型来区分重载，为什么？"><span class="toc-number">58.</span> <span class="toc-text">148. 华为的面试题中曾经问过这样一个问题：为什么不能根据返回类型来区分重载，为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#150-抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰"><span class="toc-number">59.</span> <span class="toc-text">150. 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#151-静态变量和实例变量的区别？"><span class="toc-number">60.</span> <span class="toc-text">151. 静态变量和实例变量的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#153-如何实现对象克隆？"><span class="toc-number">61.</span> <span class="toc-text">153. 如何实现对象克隆？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#158-Java-中的fifinal关键字有哪些用法？"><span class="toc-number">62.</span> <span class="toc-text">158. Java 中的fifinal关键字有哪些用法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#160-说说数据类型之间的转换"><span class="toc-number">63.</span> <span class="toc-text">160. 说说数据类型之间的转换</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/Y960303802/image/img2/1053126.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/Y960303802.github.io/">戏子</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Y960303802.github.io/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Java基础</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-02 20:22:38"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-02</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-02 20:27:57"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-02</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/Y960303802.github.io/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="4-什么是JVM？什么是JDK？-什么是JRE？"><a href="#4-什么是JVM？什么是JDK？-什么是JRE？" class="headerlink" title="4. 什么是JVM？什么是JDK？ 什么是JRE？"></a>4. 什么是JVM？什么是JDK？ 什么是JRE？</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><strong>JVM</strong></h3><p>JVM是Java Virtual Machine（Java虚拟机）的缩写，它是整个Java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。JVM是Java平台的基础，和实际的机器一 样，它也有自己的指令集，并且在运行时操作不同的内存区域。 JVM通过抽象操作系统和CPU结构，提供了一种与平 台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。JVM的主要工作是解释自己的指令集 （即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰。 JVM对上层的Java源文件是不关心 的，它关注的只是由源文件生成的类文件（.class文件）。 </p>
<h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a><strong>JRE</strong></h3><p>JRE是java runtime environment（java运行环境）的缩写。光有JVM还不能让class文件执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和lib和起来就称为jre。所以，在你写完java程序编译 成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了（jre里有运 行.class的java.exe）。JRE是Sun公司发布的一个更大的系统，它里面就有一个JVM。JRE就与具体的CPU结构和操作 系统有关，是运行Java程序必不可少的（除非用其他一些编译环境编译成.exe可执行文件……），JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。 </p>
<h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a><strong>JDK</strong></h3><p>每个学java的人都会先在机器上装一个JDK，那 让我们看一 下JDK的安装目录。在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行 java时起作用的是以下四个文件夹：bin、include、lib、jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE 包含JVM。 </p>
<p><strong>bin</strong>: 最主要的是编译器(javac.exe) </p>
<p><strong>include</strong>: java和JVM交互用的头文件 </p>
<p><strong>lib</strong>：类库 </p>
<p><strong>jre</strong>: java运行环境 </p>
<p>（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的） </p>
<p>总的来说JDK是用于java程序的开发,而jre则是只能运行class而没有编译的功能。eclipse、idea等其他IDE有自己的编 </p>
<p>译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选jre路径就ok了。 </p>
<p><strong>JDK,JRE,JVM三者关系概括如下</strong>： </p>
<p>jdk是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE。JRE是JAVA程序运行时需要的运行环境，就是说 </p>
<p>如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了。JDk、JRE内部都包含 </p>
<p>JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。 </p>
<h2 id="5-Java三种注释类型"><a href="#5-Java三种注释类型" class="headerlink" title="5. Java三种注释类型"></a>5. Java三种注释类型</h2><p>共有单行注释、多行注释、文档注释3种注释类型。 </p>
<p><strong>单行注释</strong>，采用“//”方式.只能注释一行代码。如： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//123</span></span><br></pre></td></tr></table></figure>

<p><strong>多行注释</strong>，采用“/<em>…</em>/”方式，可注释多行代码，其中不允许出现嵌套。如： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">System.out.println("a");</span></span><br><span class="line"><span class="comment">System.out.println("b"); </span></span><br><span class="line"><span class="comment">System.out.println("c");</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>文档注释</strong>，采用“/<em>*…</em>/”方式，如： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 戏子</span></span><br><span class="line"><span class="comment">* <span class="doctag">@descripted</span></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="6-八种基本数据类型及其字节数"><a href="#6-八种基本数据类型及其字节数" class="headerlink" title="6. 八种基本数据类型及其字节数"></a>6. 八种基本数据类型及其字节数</h2><p><img src="/Y960303802.github.io/" class="lazyload" data-src="D:%5CDocuments%5CDesktop%5C%E6%88%AA%E5%9B%BE%5CJavaSE%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%5C1.png"  alt="1"></p>
<h2 id="7-i-和-i的异同之处"><a href="#7-i-和-i的异同之处" class="headerlink" title="7. i++和++i的异同之处"></a>7. i++和++i的异同之处</h2><p>共同点：</p>
<p>1.i++和++i都是一条单独的语句，两者没有任何区别</p>
<p>2.如果i++,++i是一条单独的语句，两者没有任何区别</p>
<p>3.i++和++i的使用仅仅争对变量。6++和++6会报错，因为6不是变量</p>
<p>不同点</p>
<p>如果i++,++i不是一条单独的语句，他们就有区别</p>
<p>i++:先运算后增1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y=x++;</span><br><span class="line">System.out.println(<span class="string">"x="</span>+x+<span class="string">", y="</span>+y);</span><br><span class="line"><span class="comment">//以上代码运行后输出结果为：x=6, y=5</span></span><br></pre></td></tr></table></figure>

<p>++i :先增1后运算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y=++x;</span><br><span class="line">System.out.println(<span class="string">"x="</span>+x+<span class="string">", y="</span>+y);</span><br><span class="line"><span class="comment">//以上代码运行后输出结果为：x=6, y=6</span></span><br></pre></td></tr></table></figure>

<h2 id="8-amp-和-amp-amp-和-的区别和联系"><a href="#8-amp-和-amp-amp-和-的区别和联系" class="headerlink" title="8. &amp;和&amp;&amp; , |和|| 的区别和联系"></a>8. &amp;和&amp;&amp; , |和|| 的区别和联系</h2><p>&amp;和&amp;&amp;的联系(<strong>共同点</strong>)： </p>
<p>&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。 </p>
<p>操作数1&amp;操作数2，操作数1&amp;&amp;操作数2， </p>
<p>表达式1&amp;表达式2，表达式1&amp;&amp;表达式2， </p>
<p>情况1：当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</p>
<p>情况2：当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。表示逻辑与(and)，当运算符 </p>
<p>两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。 </p>
<p>&amp;和&amp;&amp;的区别(不同点)： </p>
<ol>
<li>&amp; 称为逻辑与运算符，&amp;&amp; 称为短路与运算符，也可叫逻辑与运算符。 </li>
</ol>
<p>对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。 </p>
<p>对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时，&amp;&amp;右边的操作数或表达式将不参与计算，此时最 </p>
<p>终结果都为false。 </p>
<p>综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是 </p>
<p>否进行运算，对最终的结果没有影响，结果肯定是false。推介平时多使用&amp;&amp;，因为它效率更高些。 </p>
<ol>
<li>&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操 </li>
</ol>
<p>作。 </p>
<p>|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似 </p>
<h2 id="9-用最有效率的方法算出2乘以8等于多少"><a href="#9-用最有效率的方法算出2乘以8等于多少" class="headerlink" title="9. 用最有效率的方法算出2乘以8等于多少"></a>9. 用最有效率的方法算出2乘以8等于多少</h2><p>使用位运算来实现效率最高。位运算符是对操作数以二进制比特位为单位进行操作和运算，操作数和结果都是整型 </p>
<p>数。 </p>
<p>对于位运算符“&lt;&lt;”, 是将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，位 </p>
<p>运算cpu直接支持的，效率最高。所以，2乘以8等于几的最效率的方法是2 &lt;&lt; 3 </p>
<h2 id="10-基本数据类型的类型转换规则"><a href="#10-基本数据类型的类型转换规则" class="headerlink" title="10. 基本数据类型的类型转换规则"></a>10. 基本数据类型的类型转换规则</h2><p>基本类型转换分为自动转换和强制转换。 </p>
<p>自动转换规则： </p>
<p>容量小的数据类型 可以自动转换成容量大的数据类型，也可以说低级自动向高级转换。这儿的容量指的不是字节 </p>
<p>数，而是指类型表述的范围。</p>
<p><img src="/Y960303802.github.io/" class="lazyload" data-src="D:%5CDocuments%5CDesktop%5C%E6%88%AA%E5%9B%BE%5CJavaSE%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%5C2.png"  alt="2"></p>
<p>强制转换规则： </p>
<p>高级变为低级需要强制转换。 </p>
<p>如何转换： </p>
<p>（1）、赋值运算符“=”右边的转换，先自动转换成表达式中级别最高的数据类型，再进行运算。 </p>
<p>（2）、赋值运算符“=”两侧的转换，若左边级别&gt;右边级别，会自动转换；若左边级别 == 右边级别，不用转换；若左 </p>
<p>边级别 &lt; 右边级别，需强制转换。 </p>
<p>（3）、可以将整型常量直接赋值给byte, short, char等类型变量，而不需要进行强制类型转换，前提是不超出其表述 </p>
<p>范围，否则必须进行强制转换。 </p>
<h2 id="11-if和switch的异同之处"><a href="#11-if和switch的异同之处" class="headerlink" title="11.  if和switch的异同之处"></a>11.  if和switch的异同之处</h2><p>相同之处： </p>
<p>都是分支语句，多超过一种的情况进行判断处理。 </p>
<p>不同之处： </p>
<p>switch更适合用于多分支情况，就是有很多种情况需要判断处理，判断条件类型单一，只有一个入口，在分支执行完 </p>
<p>后（如果没有break跳出），不加判断地执行下去; 而if—elseif—else多分枝主要适用于分支较少的分支结构，判断类 </p>
<p>型不是单一，只要一个分支被执行后，后边的分支不再执行。 </p>
<p>switch为等值判断（不允许比如&gt;= &lt;=），而if为等值和区间都可以，if的使用范围大。 </p>
<h2 id="12-while和do-while循环的区别"><a href="#12-while和do-while循环的区别" class="headerlink" title="12.  while和do-while循环的区别"></a>12.  while和do-while循环的区别</h2><p>while先判断后执行，第一次判断为false , 循环体一次都不执行。 </p>
<p>do while先执行 后判断，最少执行1次。 </p>
<p>如果while循环第一次判断为true, 则两种循环没有区别。 </p>
<h2 id="13-break和continue的作用"><a href="#13-break和continue的作用" class="headerlink" title="13.  break和continue的作用"></a>13.  break和continue的作用</h2><p>break: 结束当前循环并退出当前循环体。break还可以退出switch语句 </p>
<p>continue: 循环体中后续的语句不执行，但是循环没有结束，继续进行循环条件的判断（for循环还会i++）。 </p>
<p>continue只是结束本次循环。 </p>
<h2 id="14-请使用递归算法计算n！"><a href="#14-请使用递归算法计算n！" class="headerlink" title="14.  请使用递归算法计算n！"></a>14.  请使用递归算法计算n！</h2><p>Recursion 读法:[rɪˈkɜ:rʃn] 递归 </p>
<p>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且0的阶乘为1。 自然数n的阶乘写作n!。 </p>
<p>1808年，基斯顿·卡曼引进这个表示法。 亦即n!=1×2×3×…×n。阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** n阶乘 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> </span></span><br><span class="line"><span class="comment">**/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recursion</span> </span>&#123; <span class="comment">//阶乘算法 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (num==<span class="number">0</span> || num== <span class="number">1</span>)&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num*factorial(num-<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Recursion recursion = <span class="keyword">new</span> Recursion(); </span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> factorial = recursion.factorial(n); </span><br><span class="line">        System.out.println(factorial); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-递归的定义和优缺点"><a href="#15-递归的定义和优缺点" class="headerlink" title="15. 递归的定义和优缺点"></a>15. 递归的定义和优缺点</h2><p>递归算法是一种直接或者间接地调用自身算法的过程。在计算机编写程序中，递归算法对解决一大类问题是十分有效 </p>
<p>的，它往往使算法的描述简洁而且易于理解。 </p>
<p>递归算法解决问题的特点： </p>
<p>(1) 递归就是在过程或函数里调用自身。 </p>
<p>(2) 在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。 </p>
<p>(3) 递归算法解题通常显得很简洁，但运行效率较低。所以一般不提倡用递归算法设计程序。</p>
<p>(4) 在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。所 以一般不提倡用递归算法设计程序。 </p>
<h2 id="16-数组的特征"><a href="#16-数组的特征" class="headerlink" title="16. 数组的特征"></a>16. 数组的特征</h2><p>数组是（相同类型数据）的（有序）（集合） </p>
<p>数组会在内存中开辟一块连续的空间，每个空间相当于之前的一个变量，称为数组的元素element </p>
<p>元素的表示 数组名[下标或者索引] scores[7] scores[0] scores[9] </p>
<p>索引从0开始 </p>
<p>每个数组元素有默认值 double 0.0; boolean false; int 0 </p>
<p>数组元素有序的，不是大小顺序，是索引的顺序 </p>
<p>数组中可以存储基本数据类型，可以存储引用数据类型；但是对于一个数组而言，数组的类型是固定的，只能是一个 </p>
<p>length:数组的长度 </p>
<p>数组的长度是固定的，一经定义，不能再发生变化（数组的扩容)</p>
<h2 id="20-可变参数的作用和特点"><a href="#20-可变参数的作用和特点" class="headerlink" title="20. 可变参数的作用和特点"></a>20. 可变参数的作用和特点</h2><p>详解 : <a href="https://www.cnblogs.com/uptownBoy/articles/1698335.html" target="_blank" rel="noopener">https://www.cnblogs.com/uptownBoy/articles/1698335.html</a> </p>
<p><strong>总结1：可变参数</strong> </p>
<p>1.可变参数的形式 … </p>
<p>2.可变参数只能是方法的形参 </p>
<p>3.可变参数对应的实参可以0,1,2…..n个，也可以是一个数组 </p>
<p>4.在可变参数的方法中，将可变参数当做数组来处理 </p>
<p>5.可变参数最多有一个，只能是最后一个 </p>
<p>6.可变参数好处：方便 简单 减少重载方法的数量 </p>
<p>7.如果定义了可变参数的方法，不允许同时定义相同类型数组参数的方法 </p>
<p><strong>总结2： 数组做形参和可变参数做形参联系和区别</strong> </p>
<p><strong>联系：</strong> </p>
<p>1.实参都可以是数组； </p>
<p>方法体中,可变参数本质就是当做数组来处理 </p>
<p><strong>区别</strong>： </p>
<p>1.个数不同 可变参数只能有一个  数组参数可以多个 </p>
<p>2.位置不同 可变参数只能是最后一个  数组参数位置任意 </p>
<p>3.实参不同 可变参数实参可以0,1,2…..个，也可以是一个数组，数组的实参只能是数组 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123; </span><br><span class="line">        sum += values[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-面向过程和面向对象的区别"><a href="#22-面向过程和面向对象的区别" class="headerlink" title="22. 面向过程和面向对象的区别"></a>22. 面向过程和面向对象的区别</h2><p>两者都是软件开发思想，先有面向过程，后有面向对象。在大型项目中，针对面向过程的不足推出了面向对象开发思想。</p>
<p><strong>比喻:</strong> </p>
<p>面向过程是蛋炒饭，面向对象是盖浇饭。盖浇饭的好处就是“菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满 </p>
<p>意就换饭，菜不满意换菜。用软件工程的专业术语就是“可维护性”比较好，“饭” 和“菜”的耦合度比较低。蛋炒饭就不 </p>
<p>行了, 如果不满意就要丢掉重做; </p>
<p><strong>区别:</strong> </p>
<p>编程思路不同： 面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。 </p>
<p>封装性：都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。 </p>
<p>面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。 </p>
<p><strong>方法重载和方法重写（覆盖）的区别:</strong></p>
<p><img src="/Y960303802.github.io/" class="lazyload" data-src="D:%5CDocuments%5CDesktop%5C%E6%88%AA%E5%9B%BE%5CJavaSE%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%5C3.png"  alt="3"></p>
<h2 id="23-this和super关键字的作用"><a href="#23-this和super关键字的作用" class="headerlink" title="23. this和super关键字的作用"></a>23. this和super关键字的作用</h2><p>this是对象内部指代自身的引用,同时也是解决成员变量和局部变量同名问题；this可以调用成员变量，不能调用局部 变量；this也可以调用成员方法，但是在普通方法中可以省略this，在构造方法中不允许省略，必须是构造方法的第 一条语句。而且在静态方法当中不允许出现this关键字。 </p>
<p>super代表对当前对象的直接父类对象的引用，super可以调用直接父类的成员变量（注意权限修饰符的影响，比如不能访问private成员） </p>
<p>super可以调用直接父类的成员方法（注意权限修饰符的影响，比如不能访问private成员）；super可以调用直接父 类的构造方法，只限构造方法中使用，且必须是第一条语句。 </p>
<p>\24. static关键字的作用 </p>
<p>static可以修饰变量、方法、代码块和内部类 </p>
<p>static属性属于这个类所有，即由该类创建的所有对象共享同一个static属性。</p>
<p>可以对象创建后通过<strong>对象名.属性名</strong>和 <strong>类名.属性名</strong>两种方式来访问。</p>
<p>也可以在没有创建任何对象之前通过类名.属性名的方式来访问。 </p>
<p>static变量和非static变量的区别(都是成员变量，不是局部变量) </p>
<p><strong>1.在内存中份数不同</strong> </p>
<p>不管有多少个对象，static变量只有1份。对于每个对象，实例变量都会有单独的一份 </p>
<p>static变量是属于整个类的，也称为类变量。而非静态变量是属于对象的，也称为实例变量 </p>
<p><strong>2.在内存中存放的位置不同</strong>  <img src="/Y960303802.github.io/" class="lazyload" data-src="D:%5CDocuments%5CDesktop%5C%E6%88%AA%E5%9B%BE%5CJavaSE%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%5C4.png"  alt="4"></p>
<p>静态变量存在方法区中， 实例变量存在堆内存中 </p>
<p><strong>3.访问的方式不同</strong> </p>
<p>实例变量： 对象名.变量名 stu1.name=”小明明”; </p>
<p>静态变量：<em>对象名.变量名 stu1.schoolName=”西二旗小学”;</em> 不推荐如此使用 </p>
<p>类名.变量名 Student.schoolName=”东三旗小学”; 推荐使用 </p>
<p><strong>4.在内存中分配空间的时间不同</strong> </p>
<p>实例变量：创建对象的时候才分配了空间。静态变量：第一次使用类的时候 </p>
<p>Student.schoolName=”东三旗小学”;或者Student stu1 = new Student(“小明”,”男”,20,98); </p>
<p>static方法也可以通过对象名.方法名和类名.方法名两种方式来访问 static代码块。当类被第一次使用时（可能是调用static属性和方法，或者创建其对象）执行静态代码块，且只被执行 一次，主要作用是实现static属性的初始化。 </p>
<p>static内部类：属于整个外部类，而不是属于外部类的每个对象。不能访问外部类的非静态成员（变量或者方法）， </p>
<p>可以访问外部类的静态成员</p>
<p><strong>25. fifinal和abstract关键字的作用</strong> </p>
<p>fifinal和abstract是功能相反的两个关键字，可以对比记忆 </p>
<p>abstract可以用来修饰类和方法，不能用来修饰属性和构造方法；使用abstract修饰的类是抽象类，需要被继承，使 </p>
<p>用abstract修饰的方法是抽象方法，需要子类被重写。 </p>
<p>fifinal可以用来修饰类、方法和属性，不能修饰构造方法。使用fifinal修饰的类不能被继承，使用fifinal修饰的方法不能被 </p>
<p>重写，使用fifinal修饰的变量的值不能被修改，所以就成了常量。 </p>
<p>特别注意：fifinal修饰基本类型变量，其值不能改变，由原来的变量变为常量；但是fifinal修饰引用类型变量，栈内存中 的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。例如: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">final</span> People people = <span class="keyword">new</span> People(<span class="string">"xizi"</span>); </span><br><span class="line">        dog.name = <span class="string">"戏子"</span>;<span class="comment">//正确 </span></span><br><span class="line">        people = <span class="keyword">new</span> People(<span class="string">"戏子"</span>);<span class="comment">//错误 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-final、finally、finalize的区别"><a href="#26-final、finally、finalize的区别" class="headerlink" title="26. final、finally、finalize的区别"></a>26. final、finally、finalize的区别</h2><p><strong>final修饰符</strong>   (关键字)如果一个类被声明为fifinal，意味着它不能再派生出新的子类，不能作为父类被继承例如：String 类、Math类等。将变量或方法声明为fifinal，可以保证它们在使用中不被改变。被声明为fifinal的变量必须在声明时给 定初值，而在以后的引用中只能读取，不可修改。被声明为fifinal的方法也同样只能使用，不能重写，但是能够重载。 使用fifinal修饰的对象，对象的引用地址不能变，但是对象的值可以变! </p>
<p>fifinal修饰基本类型变量，其值不能改变。 </p>
<p>但是fifinal修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。</p>
<p><strong>finally</strong>  在异常处理时提供 fifinally 块来执行任何清除操作。如果有fifinally的话，则不管是否发生异常，fifinally语句都会 被执行。一般情况下，都把关闭物理连接(IO流、数据库连接、Socket连接)等相关操作，放入到此代码块中.。 </p>
<p>*<em>finalize方法名 *</em> Java 技术允许使用 fifinalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要清理工作。 fifinalize() 方法是在垃圾收集器删除对象之前被调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类 覆盖 fifinalize() 方法以整理系统资源或者执行其他清理工作。 一般情况下，此方法由JVM调用，程序员不要去调用! </p>
<h2 id="27-写出java-lang-Object类的六个常用方法"><a href="#27-写出java-lang-Object类的六个常用方法" class="headerlink" title="27. 写出java.lang.Object类的六个常用方法"></a>27. 写出java.lang.Object类的六个常用方法</h2><p>(1)public boolean <strong>equals</strong>(java.lang.Object)比较对象的地址值是否相等，如果子类重写，则比较对象的内容是否相等； </p>
<p>(2)public native int <strong>hashCode()</strong> 获取哈希码 </p>
<p>(3)public java.lang.String <strong>toString</strong>() 把数据转变成字符串 </p>
<p>(4)public fifinal native java.lang.Class <strong>getClass</strong>() 获取类结构信息 </p>
<p>(5)protected void fifinalize() throws java.lang.<strong>Throwable</strong>垃圾回收前执行的方法 </p>
<p>(6)protected native Object <strong>clone()</strong> throws java.lang.CloneNotSupportedException 克隆 </p>
<p>(7)public fifinal void <strong>wait()</strong> throws java.lang.InterruptedException多线程中等待功能 </p>
<p>(8)public fifinal native void <strong>notify()</strong> 多线程中唤醒功能 </p>
<p>(9)public fifinal native void <strong>notifyAll()</strong> 多线程中唤醒所有等待线程的功能</p>
<h2 id="28-权限修饰符的区别"><a href="#28-权限修饰符的区别" class="headerlink" title="28. 权限修饰符的区别"></a>28. 权限修饰符的区别</h2><p><img src="/Y960303802.github.io/" class="lazyload" data-src="D:%5CDocuments%5CDesktop%5C%E6%88%AA%E5%9B%BE%5CJavaSE%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%5C5.png"  alt="5"></p>
<p>类的访问权限只有两种: </p>
<p>public 公共的 可被同一项目中所有的类访问。 (必须与文件名同名) </p>
<p>default 默认的 可被同一个包中的类访问。 </p>
<p>成员(成员变量或成员方法)访问权限共有四种： </p>
<p>public 公共的 可以被项目中所有的类访问。(项目可见性) </p>
<p>protected 受保护的 可以被这个类本身访问;同一个包中的所有其他的类访问;被它的子类(同一个包以及不同包 </p>
<p>中的子类)访问。(子类可见性) </p>
<p>default 默认的被这个类本身访问;被同一个包中的类访问。(包可见性) </p>
<p>private 私有的 只能被这个类本身访问。(类可见性)</p>
<h2 id="29-继承条件下构造方法的执行过程"><a href="#29-继承条件下构造方法的执行过程" class="headerlink" title="29. 继承条件下构造方法的执行过程"></a>29. 继承条件下构造方法的执行过程</h2><p>继承条件下构造方法的调用规则如下： </p>
<p>情况1：如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构 造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，写不写“super();”语句，效果是一样的。 </p>
<p>情况2：如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法。 </p>
<p>情况3：如果子类的构造方法中通过this显式调用自身的其他构造方法，在相应构造方法中应用以上两条规则。 </p>
<p>特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直到执行 </p>
<p>顶级父类Object类的无参构造方法为止。 </p>
<h2 id="30-和equals的区别和联系"><a href="#30-和equals的区别和联系" class="headerlink" title="30. ==和equals的区别和联系"></a>30. ==和equals的区别和联系</h2><p>“==”是关系运算符，equals()是方法，同时他们的结果都返回布尔值； </p>
<p>“==”使用情况如下： </p>
<p>a) 基本类型，比较的是值 </p>
<p>b) 引用类型，比较的是地址 </p>
<p>c) 不能比较没有父子关系的两个对象 </p>
<p>equals()方法使用如下： </p>
<p>a) 系统类一般已经覆盖了equals()，比较的是内容。 </p>
<p>b) 用户自定义类如果没有覆盖equals()，将调用父类的equals（比如是Object），而Object的equals的比较是地址 </p>
<p>（return (this == obj);） </p>
<p>c) 用户自定义类需要覆盖父类的equals() </p>
<p>注意：Object的==和equals比较的都是地址，作用相同</p>
<h2 id="31-谈谈Java的多态"><a href="#31-谈谈Java的多态" class="headerlink" title="31. 谈谈Java的多态"></a>31. 谈谈Java的多态</h2><p>多态性是OOP中的一个重要特性，主要是用来实现动态联编的，换句话说，就是程序的最终状态只有在执行过程中 才被决定而非在编译期间就决定了。这对于大型系统来说能提高系统的灵活性和扩展性。 </p>
<p>多态可以让我们不用关心某个对象到底是什么具体类型，就可以使用该对象的某些方法，从而实现更加灵活的编程， 提高系统的可扩展性。 </p>
<p>实现多态的三个条件（前提条件，向上转型、向下转型） </p>
<p>1、继承的存在；（继承是多态的基础，没有继承就没有多态） </p>
<p>2、子类重写父类的方法。（多态下会调用子类重写后的方法） </p>
<p>3、父类引用变量指向子类对象。（涉及子类到父类的类型转换） </p>
<p>向上转型 Animal a = new Cat(); </p>
<p>将一个父类的引用指向一个子类对象，称为向上转型，自动进行类型转换。此时通过父类引用变量调用的方法是子类 覆盖或继承父类的方法，而不是父类的方法,此时通过父类引用变量无法调用子类特有的方法. </p>
<p>向下转型 Cat a2 = (Cat)a; </p>
<p>将一个指向子类对象的引用赋给一个子类的引用，成为向下转型，此时必须进行强制类型转换。向下转型必须转换为 父类引用指向的真实子类类型，否则将出现ClassCastException，不是任意的强制转换. </p>
<p>向下转型时可以结合使用instanceof运算符进行强制类型转换，比如出现转换异常–ClassCastException.比如：本来 是狗，我把它转成猫。就会报这个异常</p>
<h2 id="32-简述Java的垃圾回收机制"><a href="#32-简述Java的垃圾回收机制" class="headerlink" title="32. 简述Java的垃圾回收机制"></a>32. 简述Java的垃圾回收机制</h2><p>传统的C/C++语言，需要程序员负责回收已经分配内存。 </p>
<p>显式回收垃圾回收的缺点： </p>
<p>1）程序忘记及时回收，从而导致内存泄露，降低系统性能。 </p>
<p>2）程序错误回收程序核心类库的内存，导致系统崩溃。 </p>
<p>Java语言不需要程序员直接控制内存回收，是由JRE在后台自动回收不再使用的内存，称为垃圾回收机制，简称GC； </p>
<p>1）可以提高编程效率。 </p>
<p>2）保护程序的完整性。 </p>
<p>3）其开销影响性能。Java虚拟机必须跟踪程序中有用的对象，确定哪些是无用的。 </p>
<p>垃圾回收机制的特点: </p>
<p>1）垃圾回收机制回收JVM堆内存里的对象空间,不负责回收栈内存数据。 </p>
<p>2）对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力。 </p>
<p>3）垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。 </p>
<p>4）可以将对象的引用变量设置为null，暗示垃圾回收机制可以回收该对象。 </p>
<p>现在的JVM有多种垃圾回收实现算法，表现各异。 </p>
<p>垃圾回收机制回收任何对象之前，总会先调用它的fifinalize方法（如果覆盖该方法，让一个新的引用变量重新引用该 对象，则会重新激活对象）。 </p>
<p>程序员可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有一些效果，但是系统是 否进行垃圾回收依然不确定。 </p>
<p>永远不要主动调用某个对象的fifinalize方法，应该交给垃圾回收机制调用。</p>
<h2 id="33-基本数据类型和包装类"><a href="#33-基本数据类型和包装类" class="headerlink" title="33. 基本数据类型和包装类"></a>33. 基本数据类型和包装类</h2><p>1) 八个基本数据类型的包装类 </p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p>2) 为什么为基本类型引入包装类 </p>
<p>2.1、基本数据类型有方便之处，简单、高效。 </p>
<p>2.2、 但是Java中的基本数据类型却是不面向对象的（没有属性、方法），这在实际使用时存在很多的不便（比如集 合的元素只能是Object）. </p>
<p>为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行包装，这样八个和基本数据类型对应的 </p>
<p>类统称为包装类(Wrapper Class)。 </p>
<p>3) 包装类和基本数据类型之间的转换 </p>
<p>3.1包装类—— wrapperInstance.xxxValue() ——&gt;基本数据类型 </p>
<p>3.2包装类&lt;—new WrapperClass(primitive)– new WrapperClass(string)——基本数据类型 </p>
<p>4)自动装箱和自动拆箱 </p>
<p>JDK1.5提供了自动装箱（autoboxing）和自动拆箱（autounboxing）功能, 从而实现了包装类和基本数据类型之间 的自动转换 </p>
<p>5)、包装类还可以实现基本类型变量和字符串之间的转换 </p>
<p>基本类型变量————String.valueof()————&gt;字符串 </p>
<p>基本类型变量&lt;————WrapperClass.parseXxx(string)————字符串 </p>
<h2 id="34-Integer与int的区别"><a href="#34-Integer与int的区别" class="headerlink" title="34. Integer与int的区别"></a>34. Integer与int的区别</h2><p>int是java提供的8种原始数据类型之一，Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。 </p>
<p>int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的 </p>
<p>情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为 </p>
<p>null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。 </p>
<p>另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的 </p>
<p>最大值和最小值的常量。</p>
<h2 id="35-java-sql-Date和java-util-Date的联系和区别"><a href="#35-java-sql-Date和java-util-Date的联系和区别" class="headerlink" title="35. java.sql.Date和java.util.Date的联系和区别"></a>35. java.sql.Date和java.util.Date的联系和区别</h2><p>1）、java.sql.Date是java.util.Date的子类，是一个包装了毫秒值的瘦包装器，允许 JDBC 将毫秒值标识为 SQL DATE 值。毫秒值表示自 1970 年 1 月 1 日 00:00:00 GMT 以来经过的毫秒数。 为了与 SQL DATE 的定义一致，由 java.sql.Date 实例包装的毫秒值必须通过将时间、分钟、秒和毫秒设置为与该实例相关的特定时区中的零来“规范 化”。 说白了，java.sql.Date就是与数据库Date相对应的一个类型，而java.util.Date是纯java的Date。 </p>
<p>2）、JAVA里提供的日期和时间类java.sql.Date和java.sql.Timestamp,只会从数据库里读取某部分值，这有时会 导致丢失数据。例如一个包含2002/05/22 5:00:57 PM的字段，读取日期时得到的是2002/05/22,而读取时间时得到 的是5:00:57 PM. 你需要了解数据库里存储时间的精度。有些数据库，比如MySQL,精度为毫秒，然而另一些数据 库，包括Oracle,存储SQL DATE类型数据时，毫秒部分的数据是不保存的。 </p>
<p>以下操作中容易出现不易被发现的BUG：获得一个JAVA里的日期对象。 从数据库里读取日期 , 试图比较两个日期对象是否相等。如果毫秒部分丢失，本来认为相等的两个日期对象 , 用Equals方法可能返回false。.sql.Timestamp类比 java.util.Date类精确度要高。 </p>
<p>java.sql.Date 和 java.util.Date 最大的不同在于 java.sql.Date 只记录日期，而没有具体这一天的时间。所以举例来说，如果当前是2009-12-24 23:20，你创建一个 java.sql.Date 将只记下2009-12-24这个信息。若你需要 保留时间进行JDBC操作，请使用 java.sql.Timestamp 代替。 </p>
<p>总之，java.util.Date 就是Java的日期对象，而java.sql.Date 是针对SQL语句使用的，只包含日期而没有时间部分</p>
<h2 id="36-递归应用题"><a href="#36-递归应用题" class="headerlink" title="36. 递归应用题"></a>36. 递归应用题</h2><p>题目 : 使用递归算法输出某个目录下及其子目录下所有文件. </p>
<p>递归 : 自动调用自己 , 需要定义递归出口. </p>
<p>题目分析 : 参数为一个指定的目录 . 输出所有文件列表; </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File; </span><br><span class="line"><span class="comment">/** <span class="doctag">@Description</span>  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> 狂神说 </span></span><br><span class="line"><span class="comment">**/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowFile</span> </span>&#123; </span><br><span class="line">    <span class="comment">/*静态私有化方法的特点： </span></span><br><span class="line"><span class="comment">    1. 方法只能在类内部使用。 </span></span><br><span class="line"><span class="comment">    2. 性能提高，静态的函数无需检测this指针是否为空。 </span></span><br><span class="line"><span class="comment">    （一般函数的第一个参数是对象本身，而静态的可以为null,不需要额外的检查) */</span> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String path)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//list()方法是返回某个目录下的所有文件和目录的文件名，返回的是String数组 //listFiles()方法是返回某个目录下所有文件和目录的绝对路径，返回的是File数组 </span></span><br><span class="line">        File f = <span class="keyword">new</span> File(path); </span><br><span class="line">        File[] fs = f.listFiles(); </span><br><span class="line">        <span class="comment">//如果没有文件,返回空; </span></span><br><span class="line">        <span class="keyword">if</span> (fs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;<span class="comment">//递归遍历输出 </span></span><br><span class="line">        <span class="keyword">for</span> (File file : fs) &#123;</span><br><span class="line">            <span class="comment">//如果是文件就直接打印出来,否则就递归循环 </span></span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123; </span><br><span class="line">                System.out.println(file.getPath()); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                test(file.getPath()); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        String path = <span class="string">"E:\\生活\\图片"</span>;</span><br><span class="line">        test(path); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="47-说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java程序中如何检测？如何解决？"><a href="#47-说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java程序中如何检测？如何解决？" class="headerlink" title="47. 说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java程序中如何检测？如何解决？"></a>47. 说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java程序中如何检测？如何解决？</h2><p><strong>1、内存泄漏memory leak :</strong> </p>
<p>是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。 </p>
<p><strong>2、内存溢出 out of memory :</strong> </p>
<p>指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。 </p>
<p><strong>3、二者的关系：</strong></p>
<p>内存泄漏的堆积最终会导致内存溢出 内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当 </p>
<p>于没法满足你的需求，就会报内存溢出的错误。 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了 </p>
<p>以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。 内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方 </p>
<p>说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错。 </p>
<p><strong>4、内存泄漏的分类（按发生方式来分类）</strong></p>
<p>常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。 </p>
<p>偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境， 偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。 </p>
<p>一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 </p>
<p>隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。 </p>
<p><strong>5、内存溢出的原因及解决方法：</strong> </p>
<p>（1） 内存溢出原因： </p>
<p>内存中加载的数据量过于庞大，如一次从数据库取出过多数据； 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； 代码中存在死循环或循环产生过多重复的对象实体； 使用的第三方软件中的BUG； 启动参数内存值设定的过小 </p>
<p>（2）内存溢出的解决方案： </p>
<p>第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。) </p>
<p>第二步，检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。 </p>
<p>第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。 </p>
<p>重点排查以下几点： </p>
<p>1.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内 存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。 </p>
<p>2.检查代码中是否有死循环或递归调用。 </p>
<p>3.检查是否有大循环重复产生新对象实体。 </p>
<p>4.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内 存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询 就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。 </p>
<p><strong>5.检查List、MAP等集合对象是否有使用完后，未清除的问题。</strong></p>
<p>List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。 </p>
<p>第四步，使用内存查看工具动态查看内存使用情况 </p>
<h2 id="48-什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？"><a href="#48-什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？" class="headerlink" title="48. 什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？"></a>48. 什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？</h2><p>Java中的序列化机制能够将一个实例对象（只序列化对象的属性值，而不会去序列化什么所谓的方法。）的状态信息写入到一个字节流中使其可以通过socket进行传输、或者持久化到存储数据库或文件系统中；然后在需要的时候通过 字节流中的信息来重构一个相同的对象。一般而言，要使得一个类可以序列化，只需简单实现java.io.Serializable接 口即可。 </p>
<p>对象的序列化主要有两种用途：</p>
<p>1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；</p>
<p>2）在网络上传送对象的字节序列。 </p>
<p>在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消， 于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。 </p>
<p>当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形 式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。 </p>
<h2 id="49-不通过构造函数也能创建对象吗？"><a href="#49-不通过构造函数也能创建对象吗？" class="headerlink" title="49. 不通过构造函数也能创建对象吗？"></a>49. 不通过构造函数也能创建对象吗？</h2><p>Java创建对象的几种方式（重要）： </p>
<p>1、 用new语句创建对象，这是最常见的创建对象的方法。 </p>
<p>2、 运用反射手段,调用java.lang.Class或者java.lang.reflflect.Constructor类的newInstance()实例方法。 </p>
<p>3、 调用对象的clone()方法。 </p>
<p>4、运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。 </p>
<p>(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件 </p>
<p>中还原类的对象，也不会调用构造函数。 </p>
<h2 id="50-匿名内部类可不可以继承或实现接口。为什么？"><a href="#50-匿名内部类可不可以继承或实现接口。为什么？" class="headerlink" title="50. 匿名内部类可不可以继承或实现接口。为什么？"></a>50. 匿名内部类可不可以继承或实现接口。为什么？</h2><p>匿名内部类是没有名字的内部类,不能继承其它类,但一个内部类可以作为一个接口,由另一个内部类实现. </p>
<p>1、由于匿名内部类没有名字，所以它没有构造函数。因为没有构造函数，所以它必须完全借用父类的构造函数来实例化，换言之：匿名内部类完全把创建对象的任务交给了父类去完成。 </p>
<p>2、在匿名内部类里创建新的方法没有太大意义，但它可以通过覆盖父类的方法达到神奇效果，如上例所示。这是多 态性的体现。 </p>
<p>3、因为匿名内部类没有名字，所以无法进行向下的强制类型转换，持有对一个匿名内部类对象引用的变量类型一定是它的直接或间接父类类型。 </p>
<p>匿名类是不能有名称的类，所以没办法引用它们。必须在创建时，作为new语句的一部分来声明它们。这就要采用另一种形式的new语句，如下所示： new &lt;类或接口&gt; &lt;类的主体&gt; </p>
<p>这种形式的new语句声明一个新的匿名类，它对一个给定的类进行扩展，或者实现一个给定的接口。它还创建那个类的一个新实例，并把它作为语句的结果而返回。要扩展的类和要实现的接口是new语句的操作数，后跟匿名类的主 体。 </p>
<p>如果匿名类对另一个类进行扩展，它的主体可以访问类的成员、覆盖它的方法等等，这和其他任何标准的类都是一样的。如果匿名类实现了一个接口，它的主体必须实现接口的方法。 </p>
<p>注意匿名类的声明是在编译时进行的，实例化在运行时进行。这意味着for循环中的一个new语句会创建相同匿名类 的几个实例，而不是创建几个不同匿名类的一个实例。 </p>
<p>从技术上说，匿名类可被视为非静态的内部类，所以它们具有和方法内部声明的非静态内部类一样的权限和限制。 </p>
<p>如果要执行的任务需要一个对象，但却不值得创建全新的对象（原因可能是所需的类过于简单，或者是由于它只在一个方法内部使用），匿名类就显得非常有用。匿名类尤其适合在Swing应用程序中快速创建事件处理程序。 </p>
<h2 id="51-在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型"><a href="#51-在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型" class="headerlink" title="51. 在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型"></a>51. 在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型</h2><p>做为HashMap的健值，需要注意哪些地方。 </p>
<p>在Java中是使用泛型来约束HashMap中的key和value的类型的，即HashMap&lt;K, V&gt;；而泛型在Java的规定中必须是对象Object类型的，也就是说HashMap&lt;K, V&gt;可以理解为HashMap&lt;Object,Object&gt;，很显然基本数据类型不是Object类型的，因此不能作为键值，只能是引用类型。虽然我们在HashMap中可以这样添加数据：“map.put(1, “Java”)；”，但实际上是将其中的key值1进行了自动装箱操作，变为了Integer类型。 </p>
<p>引用数据类型分为两类：系统提供的引用数据类型（如包装类、String等）以及自定义引用数据类型。系统提供的引用数据类型中已经重写了HashCode()和equals()两个方法，所以能够保证Map中key值的唯一性；但是自定义的引用数据类型需要自己重写HashCode()和equals()这两个方法，以保证Map中key值的唯一性。 </p>
<h2 id="52-简述Java中如何实现多态"><a href="#52-简述Java中如何实现多态" class="headerlink" title="52. 简述Java中如何实现多态"></a>52. 简述Java中如何实现多态</h2><p>实现多态有三个前提条件： </p>
<p>1、 继承的存在；（继承是多态的基础，没有继承就没有多态）。 </p>
<p>2、子类重写父类的方法。（多态下会调用子类重写后的方法）。 </p>
<p>3、父类引用变量指向子类对象。（涉及子类到父类的类型转换）。 </p>
<p>最后使用父类的引用变量调用子类重写的方法即可实现多态。即,同一个方法 , 可以有不同的展现结果;</p>
<h2 id="53-以下对继承的描述锚误的是"><a href="#53-以下对继承的描述锚误的是" class="headerlink" title="53. 以下对继承的描述锚误的是 ()"></a>53. 以下对继承的描述锚误的是 ()</h2><p>A.  Java中的继承允许一个子类继承多个父类 </p>
<p>B.  父类更具有通用性，子类更具体 </p>
<p>C.  Java中的继承存在着传递性 </p>
<p>D.  当实例化子类时会递归调用父类中的构造方法 </p>
<p>答案：A </p>
<p>分析：<strong>Java是单继承的，一个类只能继承一个父类。</strong> </p>
<h2 id="54-Java-中-Math-random（）-Math-random（）值为？"><a href="#54-Java-中-Math-random（）-Math-random（）值为？" class="headerlink" title="54. Java 中 Math.random（）/Math.random（）值为？"></a>54. Java 中 Math.random（）/Math.random（）值为？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">//调用这个Math.Random()函数能够返回带正号的double值，该值大于等于0.0且小于1.0，即取值范围 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是[0.0,1.0)的左闭右开区间，返回值是一个伪随机选择的数，在该范围内（近似）均匀分布。 </span></span><br><span class="line"></span><br><span class="line">System.out.println(Math.random()/Math.random()); &#125; &#125;</span><br></pre></td></tr></table></figure>



<p>如果除数与被除数均不为0.0的话，则取值范围为[0, +∞]。+∞在Java中显示的结果为Infifinity。 </p>
<p>如果除数与被除数均为0.0的话，则运行结果为NaN（Not a Number的简写），计算错误。 </p>
<h2 id="55-Java中，如果Manager是Employee的子类，那么-Pair-是-Pair"><a href="#55-Java中，如果Manager是Employee的子类，那么-Pair-是-Pair" class="headerlink" title="55. Java中，如果Manager是Employee的子类，那么 Pair  是 Pair"></a>55. Java中，如果Manager是Employee的子类，那么 Pair <Manager> 是 Pair</h2><p><Employee> 的子类吗？ </p>
<p>不是，两者没有任何关联； </p>
<p>Pair是单独的类，只不过用不同类型的参数（泛型）进行了相应的实例化而已；所以, Pair<Manager> 和 </p>
<p>Pair<Employee> 不是子类的关系。 </p>
<h2 id="56-接口和抽象类的区别"><a href="#56-接口和抽象类的区别" class="headerlink" title="56. 接口和抽象类的区别"></a>56. 接口和抽象类的区别</h2><p><strong>相同点</strong> </p>
<p>抽象类和接口均包含抽象方法，类必须实现所有的抽象方法 . </p>
<p>抽象类和接口都不能实例化，他们位于继承树的顶端，用来被其他类继承和实现 </p>
<p>两者的区别主要体现在两方面：语法方面和设计理念方面 </p>
<p>语法方面的区别是比较 低层次的，非本质的，主要表现在： </p>
<p>接口中只能定义全局静态常量，不能定义变量。抽象类中可以定义常量和变量。 </p>
<p>接口中所有的方法都是全局抽象方法。抽象类中可以有0个、1个或多个，甚至全部都是抽象方法。 </p>
<p>抽象类中可以有构造方法，但不能用来实例化，而在子类实例化是执行，完成属于抽象类的初始化操作。接口中不能定义构造方法。</p>
<p> 一个类只能有一个直接父类（可以是抽象类），但可以充实实现多个接口。一个类使用extends来继承抽象类，使用 implements来实现接口。 </p>
<p>二者的主要区别还是在设计理念上，其决定了某些情况下到底使用抽象类还是接口。 </p>
<p>抽象类体现了一种继承关系，目的是复用代码，抽象类中定义了各个子类的相同代码，可以认为父类是一个实现了部分功能的“中间产品”，而子类是“最终产品”。父类和子类之间必须存在“is-a:继承”的关系，即父类和子类在概念本质上 应该是相同的。 </p>
<h2 id="57-同步代码块和同步方法有什么区别"><a href="#57-同步代码块和同步方法有什么区别" class="headerlink" title="57. 同步代码块和同步方法有什么区别"></a>57. 同步代码块和同步方法有什么区别</h2><p><strong>相同点：</strong> </p>
<p> 同步方法就是在方法前加关键字synchronized，然后被同步的方法一次只能有一个线程进入，其他线程等待。而同 步代码块则是在方法内部使用大括号使得一个代码块得到同步。同步代码块会有一个同步的“目标”，使得同步块更加 灵活一些（同步代码块可以通过“目标”决定需要锁定的对象）。一般情况下，如果此“目标”为this，那么同步方法和同 步代码块没有太大的区别。 </p>
<p><strong>区别：</strong> </p>
<p>同步方法直接在方法上加synchronized实现加锁，同步代码块则在方法内部加锁。很明显，同步方法锁的范围比较 大，而同步代码块范围要小点。一般同步的范围越大，性能就越差。所以一般需要加锁进行同步的时候，范围越小越 好，这样性能更好。 </p>
<h2 id="58-静态内部类和内部类有什么区别"><a href="#58-静态内部类和内部类有什么区别" class="headerlink" title="58. 静态内部类和内部类有什么区别"></a>58. 静态内部类和内部类有什么区别</h2><p>静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。 </p>
<p>静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。 </p>
<p>非静态内部类能够访问外部类的静态和非静态成员。静态内部类不能访问外部类的非静态成员，只能访问外部类的静态成员。</p>
<p>实例化方式不同： </p>
<p>1) 静态内部类：不依赖于外部类的实例，直接实例化内部类对象 [ 是真的类 ] </p>
<p>2) 非静态内部类：通过外部类的对象实例生成内部类对象 [ 是在对象中new出来的类 ] </p>
<p>\58. 静态内部类和内部类有什么区别 </p>
<p>静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。 </p>
<p>静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。 </p>
<p>非静态内部类能够访问外部类的静态和非静态成员。静态内部类不能访问外部类的非静态成员，只能访问外部类的静 </p>
<p>态成员。 </p>
<p>实例化方式不同： </p>
<p>1) 静态内部类：不依赖于外部类的实例，直接实例化内部类对象 [ 是真的类 ] </p>
<p>2) 非静态内部类：通过外部类的对象实例生成内部类对象 [ 是在对象中new出来的类 ] </p>
<h2 id="59-反射的概念与作用"><a href="#59-反射的概念与作用" class="headerlink" title="59. 反射的概念与作用"></a>59. 反射的概念与作用</h2><p>反射的概念： </p>
<p>反射，一种计算机处理方式。是程序可以访问、检测和修改它本身状态或行为的一种能力。 </p>
<p>Java反射可以于运行时加载,探知和使用编译期间完全未知的类. </p>
<p>程序在运行状态中, 可以动态加载一个只有名称的类, 对于任意一个已经加载的类,都能够知道这个类的所有属性 和方法; 对于任意一个对象,都能调用他的任意一个方法和属性; </p>
<p>加载完类之后, 在堆内存中会产生一个Class类型的对象(一个类只有一个Class对象), 这个对象包含了完整的类的 结构信息,而且这个Class对象就像一面镜子,透过这个镜子看到类的结构,所以被称之为:反射. </p>
<p>java反射使得我们可以在程序运行时动态加载一个类，动态获取类的基本信息和定义的方法,构造函数,域等。 除了检阅类信息外，还可以动态创建类的实例，执行类实例的方法，获取类实例的域值。反射使java这种静态 </p>
<p>语言有了动态的特性。 </p>
<p>反射的作用： </p>
<p>通过反射可以使程序代码访问装载到JVM 中的类的内部信息 </p>
<p>1) 获取已装载类的属性信息 </p>
<p>2) 获取已装载类的方法 </p>
<p>3) 获取已装载类的构造方法信息 </p>
<p>反射的优点： </p>
<p>增加程序的灵活性。</p>
<h2 id="63-下列哪一种叙述是正确的"><a href="#63-下列哪一种叙述是正确的" class="headerlink" title="63. 下列哪一种叙述是正确的()"></a>63. 下列哪一种叙述是正确的()</h2><p>A.  abstract修饰符可修饰字段，方法和类 </p>
<p>B.  抽象方法的body部分必须用一对大括号{}包住 </p>
<p>C.  声明抽象方法，大括号可有可无 </p>
<p>D.  声明抽象方法不可写出大括号</p>
<p>答案：D </p>
<p>分析： </p>
<p>abstract只能修饰方法和类，不能修饰字段；A错 </p>
<p>抽象方法不能有方法体，即没有{}；B.C错 </p>
<h2 id="64-下列语句正确的是"><a href="#64-下列语句正确的是" class="headerlink" title="64. 下列语句正确的是()"></a>64. 下列语句正确的是()</h2><p>A.  形式参数可被视为local Variable </p>
<p>B.  形式参数可被所有的字段修饰符修饰 </p>
<p>C.  形式参数为方法被调用时，真正被传递的参数 </p>
<p>D.  形式参数不可以是对象 </p>
<p>答案：A </p>
<p>分析： </p>
<p>local Variable为局部变量，形参和局部变量一样都只有在方法内才会发生作用，也只能在方法中使用，不会在方法 外可见； </p>
<p>对于形式参数只能用fifinal修饰符，其它任何修饰符都会引起编译器错误； </p>
<p>真正被传递的参数是实参； </p>
<p>形式参数可是基本数据类型也可以是引用类型（对象）。 </p>
<h2 id="78-存在使i-1-lt-i的数么"><a href="#78-存在使i-1-lt-i的数么" class="headerlink" title="78. 存在使i+1&lt;i的数么?"></a>78. 存在使i+1&lt;i的数么?</h2><p>存在, byte , int 等的的最大值, 加1后变为负数. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">byte</span> a = <span class="number">127</span>; </span><br><span class="line">        <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)(a+<span class="number">1</span>); </span><br><span class="line">        System.out.println(a+<span class="string">"\t"</span>+b); &#125; &#125;</span><br><span class="line"><span class="comment">//输出结果 127 -128</span></span><br></pre></td></tr></table></figure>

<h2 id="79-接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？"><a href="#79-接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？" class="headerlink" title="79. 接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？"></a>79. 接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？</h2><p>接口可以继承接口 </p>
<p>抽象类可以实现接口 </p>
<p>抽象类可以继承实体类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">//10进制转2进制 </span></span><br><span class="line">System.out.println(Integer.toBinaryString(<span class="number">72</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">//10进制转16进制 </span></span><br><span class="line">System.out.println(Integer.toHexString(<span class="number">72</span>)); </span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line"><span class="comment">//10进制转8进制 </span></span><br><span class="line">System.out.println(Integer.toOctalString(<span class="number">72</span>)); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 </span></span><br><span class="line"><span class="number">1001000</span> </span><br><span class="line"><span class="number">48</span></span><br><span class="line"><span class="number">110</span></span><br></pre></td></tr></table></figure>





<h2 id="85-Class类的getDeclaredFields-方法与getFields-的区别？"><a href="#85-Class类的getDeclaredFields-方法与getFields-的区别？" class="headerlink" title="85. Class类的getDeclaredFields()方法与getFields()的区别？"></a>85. Class类的getDeclaredFields()方法与getFields()的区别？</h2><p>getDeclaredFields(): 可以获取所有本类自己声明的方法, 不能获取继承的方法 </p>
<p>getFields(): 只能获取所有public声明的方法, 包括继承的方法 </p>
<h2 id="89-请解释以下常用正则含义："><a href="#89-请解释以下常用正则含义：" class="headerlink" title="89. 请解释以下常用正则含义："></a>89. 请解释以下常用正则含义：</h2><p><strong>\d</strong>: 匹配一个数字字符。等价于[0-9] </p>
<p><strong>\D</strong>: 匹配一个非数字字符。等价于^ [0-9] </p>
<p><strong>\s:</strong> 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v] </p>
<p><strong>.</strong> ：匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。 </p>
<p>*****：匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 </p>
<p><strong>+</strong>：匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 </p>
<p><strong>|</strong>:将两个匹配条件进行逻辑“或”（Or）运算 </p>
<p><strong>[0-9]{6}</strong>:匹配连续6个0-9之间的数字 </p>
<p><strong>\d+</strong>：匹配至少一个0-9之间的数字</p>
<h2 id="101-什么是编译型语言，什么是解释型语言？java可以归类到那种？"><a href="#101-什么是编译型语言，什么是解释型语言？java可以归类到那种？" class="headerlink" title="101. 什么是编译型语言，什么是解释型语言？java可以归类到那种？"></a>101. 什么是编译型语言，什么是解释型语言？java可以归类到那种？</h2><p>计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要把高级语言翻译成机器语言，计算机才能运行 高级语言所编写的程序。翻译的方式有两种，一个是编译，一个是解释。 </p>
<p>用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统把高级语言翻译成机器语言，把源高级程 序编译成为机器语言文件，比如windows下的exe文件。以后就可以直接运行而不需要编译了，因为翻译只做了一 次，运行时不需要翻译，所以一般而言，编译型语言的程序执行效率高。 解释型语言在运行的时候才翻译，比如VB语言，在执行的时候，专门有一个解释器能够将VB语言翻译成机器语言， 每个语句都是执行时才翻译。这样解释型语言每执行一次就要翻译一次，效率比较低。 编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大 型应用程序、数据库系统等时都采用它，像C/C++、Pascal/Object Pascal（Delphi）等都是编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用 </p>
<p>解释性语言，如JavaScript、VBScript、Perl、Python、Ruby、MATLAB 等等。 </p>
<p>JAVA语言是一种编译型-解释型语言，同时具备编译特性和解释特性（其实，确切的说java就是解释型语言，其所谓的编译过程只是将.java文件编程成平台无关的字节码.class文件，并不是向C一样编译成可执行的机器语言，在此请读者注意Java中所谓的“编译”和传统的“编译”的区别）。作为编译型语言，JAVA程序要被统一编译成字节码文件—— 文件后缀是class。此种文件在java中又称为类文件。java类文件不能再计算机上直接执行，它需要被java虚拟机翻译 成本地的机器码后才能执行，而java虚拟机的翻译过程则是解释性的。java字节码文件首先被加载到计算机内存中，然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为java语言的解释执行，是由java虚拟机完成的。 </p>
<h2 id="116-Java中byte表示的数值范围是什么？"><a href="#116-Java中byte表示的数值范围是什么？" class="headerlink" title="116. Java中byte表示的数值范围是什么？"></a>116. Java中byte表示的数值范围是什么？</h2><p>范围是-128至127</p>
<h2 id="117-如何将日期类型格式化为：2013-02-18-10-53-10？"><a href="#117-如何将日期类型格式化为：2013-02-18-10-53-10？" class="headerlink" title="117.如何将日期类型格式化为：2013-02-18 10:53:10？"></a>117.如何将日期类型格式化为：2013-02-18 10:53:10？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Date date= <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//第一步：将字符串（2013-02-18 10:53:10）转换成日期Date </span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>); </span><br><span class="line">            String sdate=<span class="string">"2013-02-18 10:53:10"</span>; </span><br><span class="line">            date = sdf.parse(sdate); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125;System.out.println(date); </span><br><span class="line">        <span class="comment">//第二步：将日期Date转换成字符串String </span></span><br><span class="line">        DateFormat sdf2=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>); </span><br><span class="line">        String sdate2=sdf2.format(date); </span><br><span class="line">        System.out.println(sdate2); </span><br><span class="line">    &#125; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="以下Java代码段会产生几个对象"><a href="#以下Java代码段会产生几个对象" class="headerlink" title="以下Java代码段会产生几个对象"></a>以下Java代码段会产生几个对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        String a=<span class="string">"a"</span>; </span><br><span class="line">        String b=<span class="string">"b"</span>; </span><br><span class="line">        String c=<span class="string">"c"</span>; </span><br><span class="line">        c=a+<span class="string">""</span>+b+<span class="string">""</span>+c; </span><br><span class="line">        System.out.print(c);; &#125; &#125;</span><br></pre></td></tr></table></figure>



<h2 id="122-Math-round（-11-2）的运行结果是。"><a href="#122-Math-round（-11-2）的运行结果是。" class="headerlink" title="\122. Math.round（-11.2）的运行结果是。"></a>\122. Math.round（-11.2）的运行结果是。</h2><p>答案: -11 </p>
<p>分析： </p>
<p>小数点后第一位=5 </p>
<p>正数：Math.round(11.5)=12 </p>
<p>负数：Math.round(-11.5)=-11 </p>
<p>小数点后第一位&lt;5 </p>
<p>正数： </p>
<p>Math.round(11.46)=11 </p>
<p>负数：Math.round(-11.46)=-11 </p>
<p>小数点后第一位&gt;5 </p>
<p>正数：Math.round(11.68)=12 </p>
<p>负数： </p>
<p>Math.round(-11.68)=-12 </p>
<p>根据上面例子的运行结果，我们还可以按照如下方式总结，或许更加容易记忆： </p>
<p>参数的小 </p>
<p>数点后第一位&lt;5，运算结果为参数整数部分。 </p>
<p>参数的小数点后第一位&gt;5，运算结果为参数整数部分绝对值+1，符号 </p>
<p>（即正负）不变。 </p>
<p>参数的小数点后第一位=5，正数运算结果为整数部分+1，负数运算结果为整数部分。</p>
<p><strong>终结：大于五全部加，等于五正数加，小于五全不加。</strong></p>
<h2 id="124-Java中int-long占用的字节数分别是"><a href="#124-Java中int-long占用的字节数分别是" class="headerlink" title="124. Java中int,long占用的字节数分别是"></a>124. Java中int,long占用的字节数分别是</h2><p>1：“字节”是byte，“位”是bit ； </p>
<p>2： 1 byte = 8 bit ； </p>
<p>char 在Java中是2个字节。java采用unicode，2个字节（16位）来表示一个字符。 </p>
<p>short 2个字节 </p>
<p>int 4个字节 </p>
<p>long 8个字节 </p>
<h2 id="125-System-out-println-‘a’-1-的结果是"><a href="#125-System-out-println-‘a’-1-的结果是" class="headerlink" title="125. System.out.println(‘a’+1);的结果是"></a>125. System.out.println(‘a’+1);的结果是</h2><p>‘a’是char型，1 是int行，int与char相加，char会被强转为int行，char的ASCII码对应的值是97，所以加一起打印98 </p>
<h2 id="131-成员变量用static修饰和不用static修饰有什么区别？"><a href="#131-成员变量用static修饰和不用static修饰有什么区别？" class="headerlink" title="131. 成员变量用static修饰和不用static修饰有什么区别？"></a>131. 成员变量用static修饰和不用static修饰有什么区别？</h2><p>1，两个变量的生命周期不同。 </p>
<p>成员变量随着对象的创建而存在，随着对象的被回收而释放。 静态变量随着类的加载而存在，随着类的消失而消失。 2，调用方式不同。 成员变量只能被对象调用。 静态变量可以被对象调用，还可以被类名调用。 </p>
<p>对象调用：p.country </p>
<p>类名调用 ：Person.country </p>
<p>3，别名不同。 </p>
<p>成员变量也称为实例变量。 静态变量称为类变量。 </p>
<p>4，数据存储位置不同。 </p>
<p>成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据. 静态变量数据存储在方法区(共享数据区)的静态区， 所以也叫对象的共享数据.</p>
<h2 id="132-如果变量用fifinal修饰，则怎样？如果方法fifinal修饰，则怎样？"><a href="#132-如果变量用fifinal修饰，则怎样？如果方法fifinal修饰，则怎样？" class="headerlink" title="132. 如果变量用fifinal修饰，则怎样？如果方法fifinal修饰，则怎样？"></a>132. 如果变量用fifinal修饰，则怎样？如果方法fifinal修饰，则怎样？</h2><p>1、用fifinal修饰的类不能被扩展，也就是说不可能有子类； 2、用fifinal修饰的方法不能被替换或隐藏： ①使用fifinal修饰的实例方法在其所属类的子类中不能被替换（overridden）； ②使用fifinal修饰的静态方法在其所属类的子类中不 能被重定义（redefifined）而隐藏（hidden）； </p>
<p>3、用fifinal修饰的变量最多只能赋值一次，在赋值方式上不同类型的变量或稍有不同： ①静态变量必须明确赋值一次（不能只使用类型缺省值）；作为类成员的静态变量，赋值可以在其声明中通过初始化表达式完成，也可以在静态初始化块中进行；作为接口成员的静态变量，赋值只能在其声明中通过初始化表达式完成； </p>
<p>②实例变量同样必须明确赋值一次（不能只使用类型缺省值）；赋值可以在其声明中通过初始化表达式完成，也可以在实例初始化块或构造器中进行； ③方法参数变量在方法被调用时创建，同时被初始化为对应实参值，终止于方法体（body）结束，在此期间其值不能改变； </p>
<p>④构造器参数变量在构造器被调用（通过实例创建表达式或显示的构造器调用）时创建，同时被初始化为对应实参 值，终止于构造器体结束，在此期间其值不能改变； ⑤异常处理器参数变量在有异常被try语句的catch子句捕捉到时 创建，同时被初始化为实际的异常对象，终止于catch语句块结束，在此期间其值不能改变； ⑥局部变量在其值被访 问之前必须被明确赋值；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    Integer f1 = <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">150</span>, f4 = <span class="number">150</span>; </span><br><span class="line">    System.out.println(f1 == f2); </span><br><span class="line">    System.out.println(f3 == f4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单的说，如果字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1,f2的结果是true，而f3==f4的结果是false。越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。 </p>
<h2 id="145-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#145-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="145. 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？"></a>145. 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</h2><p>答：不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上 述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈 希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。 </p>
<p>实现高质量的equals方法的诀窍包括： </p>
<p>\1. 使用==操作符检查“参数是否为这个对象的引用”； </p>
<p>\2. 使用instanceof操作符检查“参数是否为正确的类型”； </p>
<p>\3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配； </p>
<p>\4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性； </p>
<p>\5. 重写equals时总是要重写hashCode； </p>
<p>\6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。</p>
<h2 id="147-重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分"><a href="#147-重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分" class="headerlink" title="147.重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分?"></a>147.重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分?</h2><p>Java的三大特征之一，多态，包括方法的多态和对象的多态； </p>
<p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。 </p>
<p>重载（overload）发生在同一个类中，相同的方法，如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载； </p>
<p>重写（override）发生在子类与父类之间也就是继承机制当中，当父类的方法不能满足子类的要求，此时子类重写父类的方法； </p>
<h2 id="148-华为的面试题中曾经问过这样一个问题：为什么不能根据返回类型来区分重载，为什么？"><a href="#148-华为的面试题中曾经问过这样一个问题：为什么不能根据返回类型来区分重载，为什么？" class="headerlink" title="148. 华为的面试题中曾经问过这样一个问题：为什么不能根据返回类型来区分重载，为什么？"></a>148. 华为的面试题中曾经问过这样一个问题：为什么不能根据返回类型来区分重载，为什么？</h2><p>方法的重载，即使返回值类型不同，也不能改变实现功能相同或类似这一既定事实；同时方法的重载只是要求两同三 </p>
<p>不同，即在同一个类中，相同的方法名称，参数列表当中的参数类型、个数、顺序不同；跟权限修饰符和返回值类无 关 </p>
<h2 id="150-抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰"><a href="#150-抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰" class="headerlink" title="150. 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?"></a>150. 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?</h2><p>都不能。 </p>
<p>抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 </p>
<h2 id="151-静态变量和实例变量的区别？"><a href="#151-静态变量和实例变量的区别？" class="headerlink" title="151. 静态变量和实例变量的区别？"></a>151. 静态变量和实例变量的区别？</h2><p>静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它，静态变量可以实现让多个对象共享内存。 </p>
<p>两者的相同点：都有默认值而且在类的任何地方都可以调用。在Java开发中，上下文类和工具类中通常会有大量的静态成员。</p>
<h2 id="153-如何实现对象克隆？"><a href="#153-如何实现对象克隆？" class="headerlink" title="153. 如何实现对象克隆？"></a>153. 如何实现对象克隆？</h2><p>有两种方式： </p>
<p>1.实现Cloneable接口并重写Object类中的clone()方法； </p>
<p>2.实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。 </p>
<p>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。 </p>
<h2 id="158-Java-中的fifinal关键字有哪些用法？"><a href="#158-Java-中的fifinal关键字有哪些用法？" class="headerlink" title="158. Java 中的fifinal关键字有哪些用法？"></a>158. Java 中的fifinal关键字有哪些用法？</h2><p>(1)修饰类：表示该类不能被继承； </p>
<p>(2)修饰方法：表示方法不能被重写但是允许重载； </p>
<p>(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）； </p>
<p>(4)修饰对象：对象的引用地址不能变，但是对象的初始化值可以变。 </p>
<h2 id="160-说说数据类型之间的转换"><a href="#160-说说数据类型之间的转换" class="headerlink" title="160. 说说数据类型之间的转换"></a>160. 说说数据类型之间的转换</h2><p>1)如何将字符串转换为基本数据类型？ </p>
<p>2)如何将基本数据类型转换为字符串？ </p>
<p>答： </p>
<p>1)调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型； </p>
<p>2)一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf(…)方法返回相应字符串 </p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">戏子</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.yinpeng.fun/2020/05/02/Java%E5%9F%BA%E7%A1%80/">https://www.yinpeng.fun/2020/05/02/Java%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.yinpeng.fun" target="_blank">戏子</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/Y960303802.github.io/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Y960303802/image/img2/1053126.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/Y960303802.github.io/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/Y960303802.github.io/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/Y960303802.github.io/2020/05/02/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/Y960303802/image/img2/1053126.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">线程池</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/Y960303802/image/img2/1053126.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By 戏子</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener"><img class="icp-icon" src="/Y960303802.github.io/img/icp.png"/><span>赣ICP备20003959号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/Y960303802.github.io/js/utils.js"></script><script src="/Y960303802.github.io/js/main.js"></script><script src="/Y960303802.github.io/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/Y960303802.github.io/js/third-party/fireworks.js"></script><script defer id="ribbon" src="/Y960303802.github.io/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/Y960303802.github.io/js/search/local-search.js"></script></body></html>